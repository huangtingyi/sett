#include <stdio.h>
#include <stdlib.h>
#include <wwfile.h>
#include <wwlog.h>
#include <wwtiny.h>
#include <wwdb.h>
#include <list.h>
#include <wwdir.h>

#include "extend_supp.h"

/*批量数据动态从EXTEND_ATTR_DEF_RELATION中用结构缓冲方式取数据*/
int EGetExtendAttrDefRelationToStruct(struct ExtendAttrDefRelationStruct *p,
	struct ExtendAttrDefRelationStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				EXTEND_ATTR_ID,\n\
				ATTR_KEY,\n\
				METHOD,\n\
				VALUE,\n\
				PRIORITY\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE EXTEND_ATTR_DEF_RELATIONSCR FROM :statement;
		CheckSqlError(" PREPARE EXTEND_ATTR_DEF_RELATIONSCR EXTEND_ATTR_DEF_RELATIONCR");

		EXEC SQL DECLARE EXTEND_ATTR_DEF_RELATIONCR CURSOR FOR EXTEND_ATTR_DEF_RELATIONSCR;
		CheckSqlError("Declare EXTEND_ATTR_DEF_RELATIONCR");

		EXEC SQL OPEN EXTEND_ATTR_DEF_RELATIONCR;
		CheckSqlError("Open EXTEND_ATTR_DEF_RELATIONCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE EXTEND_ATTR_DEF_RELATIONCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH EXTEND_ATTR_DEF_RELATIONCR INTO
			:pSource->aiExtendAttrID,
			:pSource->asAttrKey,
			:pSource->asMethod,
			:pSource->asTypeValue,
			:pSource->aiPriority;
		CheckSqlError("Fetch EXTEND_ATTR_DEF_RELATIONCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE EXTEND_ATTR_DEF_RELATIONCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=EXTEND_ATTR_DEF_RELATION_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iExtendAttrID=	pSource->aiExtendAttrID[iCurPos];

		strcpy(p->sAttrKey,	pSource->asAttrKey[iCurPos]);
		strcpy(p->sMethod,	pSource->asMethod[iCurPos]);
		strcpy(p->sTypeValue,	pSource->asTypeValue[iCurPos]);

		p->iPriority=		pSource->aiPriority[iCurPos];

		AllTrim(p->sAttrKey);
		AllTrim(p->sMethod);
		AllTrim(p->sTypeValue);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}

/**对表EXTEND_ATTR_DEF_RELATION的链表释放函数**/
void DestroyExtendAttrDefRelation(struct ExtendAttrDefRelationStruct *ptHead)
{
	struct ExtendAttrDefRelationStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitExtendAttrDefRelation(struct ExtendAttrDefRelationStruct **pptHead)
{
	int iCnt=0;
	static struct ExtendAttrDefRelationStruct *pTemp,*ptHead=NULL;
	struct ExtendAttrDefRelationStruct Temp;
	struct ExtendAttrDefRelationStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyExtendAttrDefRelation(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct ExtendAttrDefRelationStructIn));
	sprintf(TempIn.sTableName,"EXTEND_ATTR_DEF_RELATION");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetExtendAttrDefRelationToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct ExtendAttrDefRelationStruct*)
			malloc(sizeof(struct ExtendAttrDefRelationStruct)))==NULL){

			DestroyExtendAttrDefRelation(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct ExtendAttrDefRelationStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表EXTEND_ATTR_DEF_RELATION记录数%d",iCnt);
	}

	WriteProcMsg("加载表EXTEND_ATTR_DEF_RELATION完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从EXTEND_ATTR中用结构缓冲方式取数据*/
int EGetExtendAttrToStruct(struct ExtendAttrStruct *p,
	struct ExtendAttrStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				EXTEND_ATTR_ID,\n\
				ATTR_ID,\n\
				EXTEND_SEQ,\n\
				NAME,\n\
				nvl(REMARK,' '),\n\
				FLAG,\n\
				nvl(SEARCH_METHOD,' '),\n\
				nvl(VALUE_SQL,' ')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE EXTEND_ATTRSCR FROM :statement;
		CheckSqlError(" PREPARE EXTEND_ATTRSCR EXTEND_ATTRCR");

		EXEC SQL DECLARE EXTEND_ATTRCR CURSOR FOR EXTEND_ATTRSCR;
		CheckSqlError("Declare EXTEND_ATTRCR");

		EXEC SQL OPEN EXTEND_ATTRCR;
		CheckSqlError("Open EXTEND_ATTRCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE EXTEND_ATTRCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH EXTEND_ATTRCR INTO
			:pSource->aiExtendAttrID,
			:pSource->aiAttrID,
			:pSource->aiExtendSeq,
			:pSource->asName,
			:pSource->asRemark,
			:pSource->asFlag,
			:pSource->asSearchMethod,
			:pSource->asValueSql;
		CheckSqlError("Fetch EXTEND_ATTRCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE EXTEND_ATTRCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=EXTEND_ATTR_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iExtendAttrID=		pSource->aiExtendAttrID[iCurPos];
		p->iAttrID=			pSource->aiAttrID[iCurPos];
		p->iExtendSeq=			pSource->aiExtendSeq[iCurPos];

		strcpy(p->sName,		pSource->asName[iCurPos]);
		strcpy(p->sRemark,		pSource->asRemark[iCurPos]);
		strcpy(p->sFlag,		pSource->asFlag[iCurPos]);
		strcpy(p->sSearchMethod,	pSource->asSearchMethod[iCurPos]);
		strcpy(p->sValueSql,		pSource->asValueSql[iCurPos]);

		AllTrim(p->sName);
		AllTrim(p->sRemark);
		AllTrim(p->sFlag);
		AllTrim(p->sSearchMethod);
		AllTrim(p->sValueSql);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;

	return TRUE;
}

/**对表EXTEND_ATTR的链表释放函数**/
void DestroyExtendAttr(struct ExtendAttrStruct *ptHead)
{
	struct ExtendAttrStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitExtendAttr(struct ExtendAttrStruct **pptHead)
{
	int iCnt=0;
	static struct ExtendAttrStruct *pTemp,*ptHead=NULL;
	struct ExtendAttrStruct Temp;
	struct ExtendAttrStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyExtendAttr(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct ExtendAttrStructIn));
	sprintf(TempIn.sTableName,"EXTEND_ATTR");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetExtendAttrToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct ExtendAttrStruct*)
			malloc(sizeof(struct ExtendAttrStruct)))==NULL){

			DestroyExtendAttr(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct ExtendAttrStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表EXTEND_ATTR记录数%d",iCnt);
	}

	WriteProcMsg("加载表EXTEND_ATTR完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从EXTEND_ATTR_VALUE中用结构缓冲方式取数据*/
int EGetExtendAttrValueToStruct(struct ExtendAttrValueStruct *p,
	struct ExtendAttrValueStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				VALUE_ID,\n\
				EXTEND_ATTR_ID,\n\
				VALUE,\n\
				NAME,\n\
				REMARK,\n\
				to_char(nvl(EFF_DATE,SYSDATE-3000),'yyyymmddhh24miss'),\n\
				nvl(STD_CODE,' ')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE EXTEND_ATTR_VALUESCR FROM :statement;
		CheckSqlError(" PREPARE EXTEND_ATTR_VALUESCR EXTEND_ATTR_VALUECR");

		EXEC SQL DECLARE EXTEND_ATTR_VALUECR CURSOR FOR EXTEND_ATTR_VALUESCR;
		CheckSqlError("Declare EXTEND_ATTR_VALUECR");

		EXEC SQL OPEN EXTEND_ATTR_VALUECR;
		CheckSqlError("Open EXTEND_ATTR_VALUECR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE EXTEND_ATTR_VALUECR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH EXTEND_ATTR_VALUECR INTO
			:pSource->aiValueID,
			:pSource->aiExtendAttrID,
			:pSource->asValue,
			:pSource->asName,
			:pSource->asRemark,
			:pSource->asEffDate,
			:pSource->asStdCode;
		CheckSqlError("Fetch EXTEND_ATTR_VALUECR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE EXTEND_ATTR_VALUECR;

			return FALSE;
		}

		if(pSource->iRecCnt!=EXTEND_ATTR_VALUE_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iValueID=		pSource->aiValueID[iCurPos];
		p->iExtendAttrID=	pSource->aiExtendAttrID[iCurPos];

		strcpy(p->sValue,	pSource->asValue[iCurPos]);
		strcpy(p->sName,	pSource->asName[iCurPos]);
		strcpy(p->sRemark,	pSource->asRemark[iCurPos]);
		strcpy(p->sEffDate,	pSource->asEffDate[iCurPos]);
		strcpy(p->sStdCode,	pSource->asStdCode[iCurPos]);

		AllTrim(p->sValue);
		AllTrim(p->sName);
		AllTrim(p->sRemark);
		AllTrim(p->sEffDate);
		AllTrim(p->sStdCode);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表EXTEND_ATTR_VALUE的链表释放函数**/
void DestroyExtendAttrValue(struct ExtendAttrValueStruct *ptHead)
{
	struct ExtendAttrValueStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}

int InitExtendAttrValue(struct ExtendAttrValueStruct **pptHead)
{
	int iCnt=0;
	static struct ExtendAttrValueStruct *pTemp,*ptHead=NULL;
	struct ExtendAttrValueStruct Temp;
	struct ExtendAttrValueStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyExtendAttrValue(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct ExtendAttrValueStructIn));
	sprintf(TempIn.sTableName,"EXTEND_ATTR_VALUE");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetExtendAttrValueToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct ExtendAttrValueStruct*)
			malloc(sizeof(struct ExtendAttrValueStruct)))==NULL){

			DestroyExtendAttrValue(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct ExtendAttrValueStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表EXTEND_ATTR_VALUE记录数%d",iCnt);
	}

	WriteProcMsg("加载表EXTEND_ATTR_VALUE完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从ATTR中用结构缓冲方式取数据*/
int EGetAttrToStruct(struct AttrStruct *p,struct AttrStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				ATTR_ID,\n\
				NAME,\n\
				GRADE,\n\
				nvl(VALUE_TYPE,' '),\n\
				nvl(VALUE_SQL,' ')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE ATTRSCR FROM :statement;
		CheckSqlError(" PREPARE ATTRSCR ATTRCR");

		EXEC SQL DECLARE ATTRCR CURSOR FOR ATTRSCR;
		CheckSqlError("Declare ATTRCR");

		EXEC SQL OPEN ATTRCR;
		CheckSqlError("Open ATTRCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE ATTRCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH ATTRCR INTO
			:pSource->aiAttrID,
			:pSource->asName,
			:pSource->asGrade,
			:pSource->asValueType,
			:pSource->asValueSql;
		CheckSqlError("Fetch ATTRCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE ATTRCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=ATTR_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iAttrID=		pSource->aiAttrID[iCurPos];

		strcpy(p->sName,	pSource->asName[iCurPos]);
		strcpy(p->sGrade,	pSource->asGrade[iCurPos]);
		strcpy(p->sValueType,	pSource->asValueType[iCurPos]);
		strcpy(p->sValueSql,	pSource->asValueSql[iCurPos]);

		AllTrim(p->sName);
		AllTrim(p->sGrade);
		AllTrim(p->sValueType);
		AllTrim(p->sValueSql);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}

/**对表ATTR的链表释放函数**/
void DestroyAttr(struct AttrStruct *ptHead)
{
	struct AttrStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitAttr(struct AttrStruct **pptHead)
{
	int iCnt=0;
	static struct AttrStruct *pTemp,*ptHead=NULL;
	struct AttrStruct Temp;
	struct AttrStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyAttr(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct AttrStruct));
	sprintf(TempIn.sTableName,"ATTR");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetAttrToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct AttrStruct*)
			malloc(sizeof(struct AttrStruct)))==NULL){

			DestroyAttr(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct AttrStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表ATTR记录数%d",iCnt);
	}

	WriteProcMsg("加载表ATTR完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从TABLE_FORMAT中用结构缓冲方式取数据*/
int EGetTableFormatToStruct(struct TableFormatStruct *p,
	struct TableFormatStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				FORMAT_ID,\n\
				REMARK,\n\
				nvl(TEMPLATE_ID,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE TABLE_FORMATSCR FROM :statement;
		CheckSqlError(" PREPARE TABLE_FORMATSCR TABLE_FORMATCR");

		EXEC SQL DECLARE TABLE_FORMATCR CURSOR FOR TABLE_FORMATSCR;
		CheckSqlError("Declare TABLE_FORMATCR");

		EXEC SQL OPEN TABLE_FORMATCR;
		CheckSqlError("Open TABLE_FORMATCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE TABLE_FORMATCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH TABLE_FORMATCR INTO
			:pSource->aiFormatID,
			:pSource->asRemark,
			:pSource->aiTemplateID;
		CheckSqlError("Fetch TABLE_FORMATCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE TABLE_FORMATCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=TABLE_FORMAT_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iFormatID=		pSource->aiFormatID[iCurPos];

		strcpy(p->sRemark,	pSource->asRemark[iCurPos]);

		p->iTemplateID=		pSource->aiTemplateID[iCurPos];

		AllTrim(p->sRemark);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}

/**对表TABLE_FORMAT的链表释放函数**/
void DestroyTableFormat(struct TableFormatStruct *ptHead)
{
	struct TableFormatStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}

int InitTableFormat(struct TableFormatStruct **pptHead)
{
	int iCnt=0;
	static struct TableFormatStruct *pTemp,*ptHead=NULL;
	struct TableFormatStruct Temp;
	struct TableFormatStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyTableFormat(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct TableFormatStructIn));
	sprintf(TempIn.sTableName,"TABLE_FORMAT");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetTableFormatToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct TableFormatStruct*)
			malloc(sizeof(struct TableFormatStruct)))==NULL){

			DestroyTableFormat(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct TableFormatStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表TABLE_FORMAT记录数%d",iCnt);
	}

	WriteProcMsg("加载表TABLE_FORMAT完毕总记录数%d",iCnt);

	return iCnt;
}



/*批量数据动态从TAB_TEMPLATE中用结构缓冲方式取数据*/
int EGetTabTemplateToStruct(struct TabTemplateStruct *p,
	struct TabTemplateStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				TEMPLATE_ID,\n\
				nvl(FORMAT_ID,0),\n\
				TEMPLATE_NAME,\n\
				nvl(TEMPLATE_REMARK,' ')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE TAB_TEMPLATESCR FROM :statement;
		CheckSqlError(" PREPARE TAB_TEMPLATESCR TAB_TEMPLATECR");

		EXEC SQL DECLARE TAB_TEMPLATECR CURSOR FOR TAB_TEMPLATESCR;
		CheckSqlError("Declare TAB_TEMPLATECR");

		EXEC SQL OPEN TAB_TEMPLATECR;
		CheckSqlError("Open TAB_TEMPLATECR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE TAB_TEMPLATECR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH TAB_TEMPLATECR INTO
			:pSource->aiTemplateID,
			:pSource->aiFormatID,
			:pSource->asTemplateName,
			:pSource->asTemplateRemark;
		CheckSqlError("Fetch TAB_TEMPLATECR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE TAB_TEMPLATECR;

			return FALSE;
		}

		if(pSource->iRecCnt!=TAB_TEMPLATE_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iTemplateID=			pSource->aiTemplateID[iCurPos];
		p->iFormatID=			pSource->aiFormatID[iCurPos];

		strcpy(p->sTemplateName,	pSource->asTemplateName[iCurPos]);
		strcpy(p->sTemplateRemark,	pSource->asTemplateRemark[iCurPos]);

		AllTrim(p->sTemplateName);
		AllTrim(p->sTemplateRemark);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}

/**对表TAB_TEMPLATE的链表释放函数**/
void DestroyTabTemplate(struct TabTemplateStruct *ptHead)
{
	struct TabTemplateStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}

int InitTabTemplate(struct TabTemplateStruct **pptHead)
{
	int iCnt=0;
	static struct TabTemplateStruct *pTemp,*ptHead=NULL;
	struct TabTemplateStruct Temp;
	struct TabTemplateStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyTabTemplate(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct TabTemplateStructIn));
	sprintf(TempIn.sTableName,"TAB_TEMPLATE");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetTabTemplateToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct TabTemplateStruct*)
			malloc(sizeof(struct TabTemplateStruct)))==NULL){

			DestroyTabTemplate(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct TabTemplateStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表TAB_TEMPLATE记录数%d",iCnt);
	}

	WriteProcMsg("加载表TAB_TEMPLATE完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从TAB_COLUMNS中用结构缓冲方式取数据*/
int EGetTabColumnsToStruct(struct TabColumnsStruct *p,
	struct TabColumnsStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				COLUMN_ID,\n\
				nvl(TEMPLATE_ID,0),\n\
				COLUMN_NAME,\n\
				DATA_TYPE,\n\
				LEN,\n\
				nvl(COLUMN_REMARK,' '),\n\
				nvl(SCALE,0),\n\
				nvl(NULLABLE,' '),\n\
				nvl(COLUMN_SEQ,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE TAB_COLUMNSSCR FROM :statement;
		CheckSqlError(" PREPARE TAB_COLUMNSSCR TAB_COLUMNSCR");

		EXEC SQL DECLARE TAB_COLUMNSCR CURSOR FOR TAB_COLUMNSSCR;
		CheckSqlError("Declare TAB_COLUMNSCR");

		EXEC SQL OPEN TAB_COLUMNSCR;
		CheckSqlError("Open TAB_COLUMNSCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE TAB_COLUMNSCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH TAB_COLUMNSCR INTO
			:pSource->aiColumnID,
			:pSource->aiTemplateID,
			:pSource->asColumnName,
			:pSource->asDataType,
			:pSource->aiLen,
			:pSource->asColumnRemark,
			:pSource->aiScale,
			:pSource->asNullable,
			:pSource->aiColumnSeq;
		CheckSqlError("Fetch TAB_COLUMNSCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE TAB_COLUMNSCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=TAB_COLUMNS_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iColumnID=			pSource->aiColumnID[iCurPos];
		p->iTemplateID=			pSource->aiTemplateID[iCurPos];

		strcpy(p->sColumnName,		pSource->asColumnName[iCurPos]);
		strcpy(p->sDataType,		pSource->asDataType[iCurPos]);

		p->iLen=			pSource->aiLen[iCurPos];

		strcpy(p->sColumnRemark,	pSource->asColumnRemark[iCurPos]);

		p->iScale=			pSource->aiScale[iCurPos];

		strcpy(p->sNullable,		pSource->asNullable[iCurPos]);

		p->iColumnSeq=			pSource->aiColumnSeq[iCurPos];

		AllTrim(p->sColumnName);
		AllTrim(p->sDataType);
		AllTrim(p->sColumnRemark);
		AllTrim(p->sNullable);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}

/**对表TAB_COLUMNS的链表释放函数**/
void DestroyTabColumns(struct TabColumnsStruct *ptHead)
{
	struct TabColumnsStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitTabColumns(struct TabColumnsStruct **pptHead)
{
	int iCnt=0;
	static struct TabColumnsStruct *pTemp,*ptHead=NULL;
	struct TabColumnsStruct Temp;
	struct TabColumnsStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyTabColumns(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct TabColumnsStructIn));
	sprintf(TempIn.sTableName,"TAB_COLUMNS");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetTabColumnsToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;
		Temp.pHead=NULL;

		if((pTemp=(struct TabColumnsStruct*)
			malloc(sizeof(struct TabColumnsStruct)))==NULL){

			DestroyTabColumns(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct TabColumnsStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表TAB_COLUMNS记录数%d",iCnt);
	}

	WriteProcMsg("加载表TAB_COLUMNS完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从TAB_TEMPLATE_REAL中用结构缓冲方式取数据*/
int EGetTabTemplateRealToStruct(struct TabTemplateRealStruct *p,
	struct TabTemplateRealStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(TEMPLATE_ID,0),\n\
				nvl(REAL_NAME,' '),\n\
				nvl(REAL_REMARK,' ')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE TAB_TEMPLATE_REALSCR FROM :statement;
		CheckSqlError(" PREPARE TAB_TEMPLATE_REALSCR TAB_TEMPLATE_REALCR");

		EXEC SQL DECLARE TAB_TEMPLATE_REALCR CURSOR FOR TAB_TEMPLATE_REALSCR;
		CheckSqlError("Declare TAB_TEMPLATE_REALCR");

		EXEC SQL OPEN TAB_TEMPLATE_REALCR;
		CheckSqlError("Open TAB_TEMPLATE_REALCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE TAB_TEMPLATE_REALCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH TAB_TEMPLATE_REALCR INTO
			:pSource->aiTemplateID,
			:pSource->asRealName,
			:pSource->asRealRemark;
		CheckSqlError("Fetch TAB_TEMPLATE_REALCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE TAB_TEMPLATE_REALCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=TAB_TEMPLATE_REAL_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iTemplateID=		pSource->aiTemplateID[iCurPos];

		strcpy(p->sRealName,	pSource->asRealName[iCurPos]);
		strcpy(p->sRealRemark,	pSource->asRealRemark[iCurPos]);

		AllTrim(p->sRealName);
		AllTrim(p->sRealRemark);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表TAB_TEMPLATE_REAL的链表释放函数**/
void DestroyTabTemplateReal(struct TabTemplateRealStruct *ptHead)
{
	struct TabTemplateRealStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitTabTemplateReal(struct TabTemplateRealStruct **pptHead)
{
	int iCnt=0;
	static struct TabTemplateRealStruct *pTemp,*ptHead=NULL;
	struct TabTemplateRealStruct Temp;
	struct TabTemplateRealStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyTabTemplateReal(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct TabTemplateRealStructIn));
	sprintf(TempIn.sTableName,"TAB_TEMPLATE_REAL");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetTabTemplateRealToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct TabTemplateRealStruct*)
			malloc(sizeof(struct TabTemplateRealStruct)))==NULL){

			DestroyTabTemplateReal(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct TabTemplateRealStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表TAB_TEMPLATE_REAL记录数%d",iCnt);
	}

	WriteProcMsg("加载表TAB_TEMPLATE_REAL完毕总记录数%d",iCnt);

	return iCnt;
}



/*批量数据动态从PROMISE_ELEMENT中用结构缓冲方式取数据*/
int EGetPromiseElementToStruct(struct PromiseElementStruct *p,
	struct PromiseElementStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				PROMISE_ELEMENT_ID,\n\
				PRIMARY_ELEMENT_ID,\n\
				SERVICE_TYPE,\n\
				AFFECT_TYPE,\n\
				PROMISE_TYPE,\n\
				NAME,\n\
				nvl(STD_NAME,' '),\n\
				REMARK,\n\
				nvl(RATE_UNIT,' '),\n\
				nvl(DISPLAY_SEQ,0),\n\
				nvl(PRIORITY,5)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE PROMISE_ELEMENTSCR FROM :statement;
		CheckSqlError(" PREPARE PROMISE_ELEMENTSCR PROMISE_ELEMENTCR");

		EXEC SQL DECLARE PROMISE_ELEMENTCR CURSOR FOR PROMISE_ELEMENTSCR;
		CheckSqlError("Declare PROMISE_ELEMENTCR");

		EXEC SQL OPEN PROMISE_ELEMENTCR;
		CheckSqlError("Open PROMISE_ELEMENTCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE PROMISE_ELEMENTCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH PROMISE_ELEMENTCR INTO
			:pSource->aiPromiseElementID,
			:pSource->aiPrimaryElementID,
			:pSource->asServiceType,
			:pSource->asAffectType,
			:pSource->asPromiseType,
			:pSource->asName,
			:pSource->asStdName,
			:pSource->asRemark,
			:pSource->asRateUnit,
			:pSource->aiDisplaySeq,
			:pSource->aiPriority;
		CheckSqlError("Fetch PROMISE_ELEMENTCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE PROMISE_ELEMENTCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=PROMISE_ELEMENT_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iPromiseElementID=	pSource->aiPromiseElementID[iCurPos];
		p->iPrimaryElementID=	pSource->aiPrimaryElementID[iCurPos];

		strcpy(p->sServiceType,	pSource->asServiceType[iCurPos]);
		strcpy(p->sAffectType,	pSource->asAffectType[iCurPos]);
		strcpy(p->sPromiseType,	pSource->asPromiseType[iCurPos]);
		strcpy(p->sName,	pSource->asName[iCurPos]);
		strcpy(p->sStdName,	pSource->asStdName[iCurPos]);
		strcpy(p->sRemark,	pSource->asRemark[iCurPos]);
		strcpy(p->sRateUnit,	pSource->asRateUnit[iCurPos]);

		p->iDisplaySeq=		pSource->aiDisplaySeq[iCurPos];
		p->iPriority=		pSource->aiPriority[iCurPos];
		
		

		AllTrim(p->sServiceType);
		AllTrim(p->sAffectType);
		AllTrim(p->sPromiseType);
		AllTrim(p->sName);
		AllTrim(p->sStdName);
		AllTrim(p->sRemark);
		AllTrim(p->sRateUnit);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}

/**对表PROMISE_ELEMENT的链表释放函数**/
void DestroyPromiseElement(struct PromiseElementStruct *ptHead)
{
	struct PromiseElementStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitPromiseElement(struct PromiseElementStruct **pptHead)
{
	int iCnt=0;
	static struct PromiseElementStruct *pTemp,*ptHead=NULL;
	struct PromiseElementStruct Temp;
	struct PromiseElementStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyPromiseElement(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct PromiseElementStructIn));
	sprintf(TempIn.sTableName,"PROMISE_ELEMENT");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetPromiseElementToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct PromiseElementStruct*)
			malloc(sizeof(struct PromiseElementStruct)))==NULL){

			DestroyPromiseElement(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct PromiseElementStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表PROMISE_ELEMENT记录数%d",iCnt);
	}

	WriteProcMsg("加载表PROMISE_ELEMENT完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从PROMISE_TARIFF中用结构缓冲方式取数据*/
int EGetPromiseTariffToStruct(struct PromiseTariffStruct *p,
	struct PromiseTariffStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				TARIFF_ID,\n\
				nvl(PROMISE_ELEMENT_ID,0),\n\
				nvl(MEASURE_SPAN_ID,-1),\n\
				nvl(TIME_SPAN_GRP_ID,-1),\n\
				nvl(BILLING_TYPE_ID,' '),\n\
				PROMISE_TYPE,\n\
				DISPLAY_SEQ,\n\
				AREA_CODE,\n\
				RATE,\n\
				RATE_UNIT,\n\
				nvl(RATE_METHOD,'R'),\n\
				nvl(RATE_ID,0),\n\
				nvl(STATE,' '),\n\
				nvl(ACCT_ITEM_TYPE_ID,-1),\n\
				nvl(CALL_AREA_TYPE_ID,-1)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE PROMISE_TARIFFSCR FROM :statement;
		CheckSqlError(" PREPARE PROMISE_TARIFFSCR PROMISE_TARIFFCR");

		EXEC SQL DECLARE PROMISE_TARIFFCR CURSOR FOR PROMISE_TARIFFSCR;
		CheckSqlError("Declare PROMISE_TARIFFCR");

		EXEC SQL OPEN PROMISE_TARIFFCR;
		CheckSqlError("Open PROMISE_TARIFFCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE PROMISE_TARIFFCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH PROMISE_TARIFFCR INTO
			:pSource->aiTariffID,
			:pSource->aiPromiseElementID,
			:pSource->aiMeasureSpanID,
			:pSource->aiTimeSpanGrpID,
			:pSource->asBillingTypeID,
			:pSource->asPromiseType,
			:pSource->aiDisplaySeq,
			:pSource->asAreaCode,
			:pSource->adRate,
			:pSource->asRateUnit,
			:pSource->asRateMethod,
			:pSource->aiRateID,
			:pSource->asState,
			:pSource->aiAcctItemTypeID,
			:pSource->aiCallAreaTypeID;
		CheckSqlError("Fetch PROMISE_TARIFFCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE PROMISE_TARIFFCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=PROMISE_TARIFF_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iTariffID=			pSource->aiTariffID[iCurPos];
		p->iPromiseElementID=		pSource->aiPromiseElementID[iCurPos];
		p->iMeasureSpanID=		pSource->aiMeasureSpanID[iCurPos];
		p->iTimeSpanGrpID=		pSource->aiTimeSpanGrpID[iCurPos];

		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);
		strcpy(p->sPromiseType,		pSource->asPromiseType[iCurPos]);

		p->iDisplaySeq=			pSource->aiDisplaySeq[iCurPos];

		strcpy(p->sAreaCode,		pSource->asAreaCode[iCurPos]);

		p->dRate=			pSource->adRate[iCurPos];

		strcpy(p->sRateUnit,		pSource->asRateUnit[iCurPos]);
		strcpy(p->sRateMethod,		pSource->asRateMethod[iCurPos]);
		
		p->iRateID=			pSource->aiRateID[iCurPos];
		
		strcpy(p->sState,		pSource->asState[iCurPos]);

		p->iAcctItemTypeID=		pSource->aiAcctItemTypeID[iCurPos];
		p->iCallAreaTypeID=		pSource->aiCallAreaTypeID[iCurPos];

		AllTrim(p->sBillingTypeID);
		AllTrim(p->sPromiseType);
		AllTrim(p->sAreaCode);
		AllTrim(p->sRateUnit);
		AllTrim(p->sRateMethod);
		AllTrim(p->sState);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}


/**对表PROMISE_TARIFF的链表释放函数**/
void DestroyPromiseTariff(struct PromiseTariffStruct *ptHead)
{
	struct PromiseTariffStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitPromiseTariff(struct PromiseTariffStruct **pptHead)
{
	int iCnt=0;
	static struct PromiseTariffStruct *pTemp,*ptHead=NULL;
	struct PromiseTariffStruct Temp;
	struct PromiseTariffStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyPromiseTariff(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct PromiseTariffStructIn));
	sprintf(TempIn.sTableName,"PROMISE_TARIFF");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetPromiseTariffToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct PromiseTariffStruct*)
			malloc(sizeof(struct PromiseTariffStruct)))==NULL){

			DestroyPromiseTariff(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct PromiseTariffStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表PROMISE_TARIFF记录数%d",iCnt);
	}

	WriteProcMsg("加载表PROMISE_TARIFF完毕总记录数%d",iCnt);

	return iCnt;
}
#ifdef EGETMEASURESPAN
/*批量数据动态从MEASURE_SPAN_TYPE中用结构缓冲方式取数据*/
int EGetMeasureSpanTypeToStruct(struct MeasureSpanTypeStruct *p,
	struct MeasureSpanTypeStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				MEASURE_SPAN_TYPE_ID,\n\
				NAME,\n\
				RATE_UNIT\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE MEASURE_SPAN_TYPESCR FROM :statement;
		CheckSqlError(" PREPARE MEASURE_SPAN_TYPESCR MEASURE_SPAN_TYPECR");

		EXEC SQL DECLARE MEASURE_SPAN_TYPECR CURSOR FOR MEASURE_SPAN_TYPESCR;
		CheckSqlError("Declare MEASURE_SPAN_TYPECR");

		EXEC SQL OPEN MEASURE_SPAN_TYPECR;
		CheckSqlError("Open MEASURE_SPAN_TYPECR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE MEASURE_SPAN_TYPECR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH MEASURE_SPAN_TYPECR INTO
			:pSource->aiMeasureSpanTypeID,
			:pSource->asName,
			:pSource->sRateUnit;
		CheckSqlError("Fetch MEASURE_SPAN_TYPECR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE MEASURE_SPAN_TYPECR;

			return FALSE;
		}

		if(pSource->iRecCnt!=MEASURE_SPAN_TYPE_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iMeasureSpanTypeID=	pSource->aiMeasureSpanTypeID[iCurPos];

		strcpy(p->sName,	pSource->asName[iCurPos]);
		strcpy(p->sRateUnit,	pSource->asRateUnit[iCurPos]);
		
		AllTrim(p->sRateUnit);
		AllTrim(p->sName);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表MEASURE_SPAN_TYPE的链表释放函数**/
void DestroyMeasureSpanType(struct MeasureSpanTypeStruct *ptHead)
{
	struct MeasureSpanTypeStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitMeasureSpanType(struct MeasureSpanTypeStruct **pptHead)
{
	int iCnt=0;
	static struct MeasureSpanTypeStruct *pTemp,*ptHead=NULL;
	struct MeasureSpanTypeStruct Temp;
	struct MeasureSpanTypeStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyMeasureSpanType(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct MeasureSpanTypeStructIn));
	sprintf(TempIn.sTableName,"MEASURE_SPAN_TYPE");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetMeasureSpanTypeToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct MeasureSpanTypeStruct*)
			malloc(sizeof(struct MeasureSpanTypeStruct)))==NULL){

			DestroyMeasureSpanType(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct MeasureSpanTypeStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表MEASURE_SPAN_TYPE记录数%d",iCnt);
	}

	WriteProcMsg("加载表MEASURE_SPAN_TYPE完毕总记录数%d",iCnt);

	return iCnt;
}
#endif
/*批量数据动态从MEASURE_FIELD_FEE中用结构缓冲方式取数据*/
int EGetMeasureFieldFeeToStruct(struct MeasureFieldFeeStruct *p,
	struct MeasureFieldFeeStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				MEASURE_FIELD_ID,\n\
				FEE_FIELD_ID,\n\
				nvl(ACCT_ITEM_TYPE_ID,-1),\n\
				nvl(FEE_FIELD_ID_SEQ,0),\n\
				nvl(FORMAT_ID,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE MEASURE_FIELD_FEESCR FROM :statement;
		CheckSqlError(" PREPARE MEASURE_FIELD_FEESCR MEASURE_FIELD_FEECR");

		EXEC SQL DECLARE MEASURE_FIELD_FEECR CURSOR FOR MEASURE_FIELD_FEESCR;
		CheckSqlError("Declare MEASURE_FIELD_FEECR");

		EXEC SQL OPEN MEASURE_FIELD_FEECR;
		CheckSqlError("Open MEASURE_FIELD_FEECR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE MEASURE_FIELD_FEECR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH MEASURE_FIELD_FEECR INTO
			:pSource->aiMeasureFieldID,
			:pSource->aiFeeFieldID,
			:pSource->aiAcctItemTypeID,
			:pSource->aiFeeFieldIDSeq,
			:pSource->aiFormatID;
		CheckSqlError("Fetch MEASURE_FIELD_FEECR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE MEASURE_FIELD_FEECR;

			return FALSE;
		}

		if(pSource->iRecCnt!=MEASURE_FIELD_FEE_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iMeasureFieldID=	pSource->aiMeasureFieldID[iCurPos];
		p->iFeeFieldID=		pSource->aiFeeFieldID[iCurPos];
		p->iAcctItemTypeID=	pSource->aiAcctItemTypeID[iCurPos];
		p->iFeeFieldIDSeq=	pSource->aiFeeFieldIDSeq[iCurPos];
		p->iFormatID=		pSource->aiFormatID[iCurPos];

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表MEASURE_FIELD_FEE的链表释放函数**/
void DestroyMeasureFieldFee(struct MeasureFieldFeeStruct *ptHead)
{
	struct MeasureFieldFeeStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitMeasureFieldFee(struct MeasureFieldFeeStruct **pptHead)
{
	int iCnt=0;
	static struct MeasureFieldFeeStruct *pTemp,*ptHead=NULL;
	struct MeasureFieldFeeStruct Temp;
	struct MeasureFieldFeeStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyMeasureFieldFee(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct MeasureFieldFeeStructIn));
	sprintf(TempIn.sTableName,"MEASURE_FIELD_FEE");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetMeasureFieldFeeToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct MeasureFieldFeeStruct*)
			malloc(sizeof(struct MeasureFieldFeeStruct)))==NULL){

			DestroyMeasureFieldFee(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct MeasureFieldFeeStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表MEASURE_FIELD_FEE记录数%d",iCnt);
	}

	WriteProcMsg("加载表MEASURE_FIELD_FEE完毕总记录数%d",iCnt);

	return iCnt;
}
/*批量数据动态从MEASURE_SPAN中用结构缓冲方式取数据*/
int EGetMeasureSpanToStruct(struct MeasureSpanStruct *p,
	struct MeasureSpanStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				MEASURE_SPAN_ID,\n\
				nvl(MEASURE_SPAN_TYPE_ID,-1),\n\
				nvl(RATE_UNIT,'S'),\n\
				BEGIN_CNT,\n\
				END_CNT,\n\
				NAME,\n\
				SERVICE_TYPE,\n\
				nvl(USE_TYPE,'T')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE MEASURE_SPANSCR FROM :statement;
		CheckSqlError(" PREPARE MEASURE_SPANSCR MEASURE_SPANCR");

		EXEC SQL DECLARE MEASURE_SPANCR CURSOR FOR MEASURE_SPANSCR;
		CheckSqlError("Declare MEASURE_SPANCR");

		EXEC SQL OPEN MEASURE_SPANCR;
		CheckSqlError("Open MEASURE_SPANCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE MEASURE_SPANCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH MEASURE_SPANCR INTO
			:pSource->aiMeasureSpanID,
			:pSource->aiMeasureSpanTypeID,
			:pSource->asRateUnit,
			:pSource->aiBeginCnt,
			:pSource->aiEndCnt,
			:pSource->asName,
			:pSource->asServiceType,
			:pSource->asUseType;
		CheckSqlError("Fetch MEASURE_SPANCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE MEASURE_SPANCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=MEASURE_SPAN_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iMeasureSpanID=	pSource->aiMeasureSpanID[iCurPos];
		p->iMeasureSpanTypeID=	pSource->aiMeasureSpanTypeID[iCurPos];
		strcpy(p->sRateUnit,	pSource->asRateUnit[iCurPos]);
		p->iBeginCnt=		pSource->aiBeginCnt[iCurPos];
		p->iEndCnt=		pSource->aiEndCnt[iCurPos];

		strcpy(p->sName,	pSource->asName[iCurPos]);
		strcpy(p->sServiceType,	pSource->asServiceType[iCurPos]);
		strcpy(p->sUseType,	pSource->asUseType[iCurPos]);

		AllTrim(p->sRateUnit);
		AllTrim(p->sName);
		AllTrim(p->sServiceType);
		AllTrim(p->sUseType);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表MEASURE_SPAN的链表释放函数**/
void DestroyMeasureSpan(struct MeasureSpanStruct *ptHead)
{
	struct MeasureSpanStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitMeasureSpan(struct MeasureSpanStruct **pptHead)
{
	int iCnt=0;
	static struct MeasureSpanStruct *pTemp,*ptHead=NULL;
	struct MeasureSpanStruct Temp;
	struct MeasureSpanStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyMeasureSpan(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct MeasureSpanStructIn));
	sprintf(TempIn.sTableName,"V_MEASURE_SPAN");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetMeasureSpanToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct MeasureSpanStruct*)
			malloc(sizeof(struct MeasureSpanStruct)))==NULL){

			DestroyMeasureSpan(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct MeasureSpanStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表%s记录数%d",TempIn.sTableName,iCnt);
	}

	WriteProcMsg("加载表%s完毕总记录数%d",TempIn.sTableName,iCnt);

	return iCnt;
}
/*批量数据动态从TIME_SPAN_GRP中用结构缓冲方式取数据*/
int EGetTimeSpanGrpToStruct(struct TimeSpanGrpStruct *p,
	struct TimeSpanGrpStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				TIME_SPAN_GRP_ID,\n\
				nvl(TIME_SPAN_TYPE_ID,-1),\n\
				nvl(CONDITION_TYPE,'A'),\n\
				NAME,\n\
				TIME_SPAN_ID,\n\
				BEGIN_TIME,\n\
				END_TIME,\n\
				DATE_TYPE, \n\
				'1' BEGIN_FLAG \n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE TIME_SPAN_GRPSCR FROM :statement;
		CheckSqlError(" PREPARE TIME_SPAN_GRPSCR TIME_SPAN_GRPCR");

		EXEC SQL DECLARE TIME_SPAN_GRPCR CURSOR FOR TIME_SPAN_GRPSCR;
		CheckSqlError("Declare TIME_SPAN_GRPCR");

		EXEC SQL OPEN TIME_SPAN_GRPCR;
		CheckSqlError("Open TIME_SPAN_GRPCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE TIME_SPAN_GRPCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH TIME_SPAN_GRPCR INTO
			:pSource->aiTimeSpanGrpID,
			:pSource->aiTimeSpanTypeID,
			:pSource->asConditionType,
			:pSource->asName,
			:pSource->aiTimeSpanID,
			:pSource->asBeginTime,
			:pSource->asEndTime,
			:pSource->asDateType,
			:pSource->asBeginFlag;
		CheckSqlError("Fetch TIME_SPAN_GRPCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE TIME_SPAN_GRPCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=TIME_SPAN_GRP_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iTimeSpanGrpID=		pSource->aiTimeSpanGrpID[iCurPos];
		p->iTimeSpanTypeID=		pSource->aiTimeSpanTypeID[iCurPos];
		
		strcpy(p->sConditionType,	pSource->asConditionType[iCurPos]);
		strcpy(p->sName,		pSource->asName[iCurPos]);

		p->iTimeSpanID=			pSource->aiTimeSpanID[iCurPos];

		strcpy(p->sBeginTime,		pSource->asBeginTime[iCurPos]);
		strcpy(p->sEndTime,		pSource->asEndTime[iCurPos]);
		strcpy(p->sDateType,		pSource->asDateType[iCurPos]);
		strcpy(p->sBeginFlag,		pSource->asBeginFlag[iCurPos]);
		
		AllTrim(p->sName);
		AllTrim(p->sConditionType);
		AllTrim(p->sBeginTime);
		AllTrim(p->sEndTime);
		AllTrim(p->sDateType);
		AllTrim(p->sBeginFlag);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表TIME_SPAN_GRP的链表释放函数**/
void DestroyTimeSpanGrp(struct TimeSpanGrpStruct *ptHead)
{
	struct TimeSpanGrpStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitTimeSpanGrp(struct TimeSpanGrpStruct **pptHead)
{
	int iCnt=0;
	static struct TimeSpanGrpStruct *pTemp,*ptHead=NULL;
	static struct TimeSpanGrpStruct Temp;
	struct TimeSpanGrpStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyTimeSpanGrp(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct TimeSpanGrpStructIn));
	sprintf(TempIn.sTableName,"V_TIME_SPAN_GRP");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetTimeSpanGrpToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct TimeSpanGrpStruct*)
			malloc(sizeof(struct TimeSpanGrpStruct)))==NULL){

			DestroyTimeSpanGrp(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct TimeSpanGrpStruct));


		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表V_TIME_SPAN_GRP记录数%d",iCnt);
	}

	WriteProcMsg("加载表V_TIME_SPAN_GRP完毕总记录数%d",iCnt);

	return iCnt;
}

int EGetValueNameToStruct(struct ValueNameStruct *p,
	struct ValueNameStructIn *pSource)
{
	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];
		
		sprintf(statement,"\n\
			SELECT \n\
				VALUE,\n\
				NAME \n\
			FROM %s %s",sTableName,sCondition);


		EXEC SQL PREPARE VALUE_NAMESCR FROM :statement;
		CheckSqlError(" PREPARE VALUE_NAMESCR VALUE_NAMECR");

		EXEC SQL DECLARE VALUE_NAMECR CURSOR FOR VALUE_NAMESCR;
		CheckSqlError("Declare VALUE_NAMECR");

		EXEC SQL OPEN VALUE_NAMECR;
		CheckSqlError("Open VALUE_NAMECR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE VALUE_NAMECR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH VALUE_NAMECR INTO
			:pSource->asValue,
			:pSource->asName;
		CheckSqlError("Fetch VALUE_NAMECR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE VALUE_NAMECR;

			return FALSE;
		}

		if(pSource->iRecCnt!=VALUE_NAME_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sValue,pSource->asValue[iCurPos]);
		strcpy(p->sName, pSource->asName[iCurPos]);
		
		AllTrim(p->sValue);
		AllTrim(p->sName);
	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	
	return TRUE;	
}
TRIE *GetValueNameTrie(char sMicro[],char sSql[])
{
	int iCnt=0;
	TRIE *pTrie=NULL;
	struct ValueNameStruct *pTemp,*ptHead=NULL;
	struct ValueNameStruct Temp;
	struct ValueNameStructIn TempIn;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct ValueNameStructIn));
	sprintf(TempIn.sTableName,"(%s)",sSql);
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetValueNameToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;
		Temp.iValueLen=strlen(Temp.sValue);

		if((pTemp=(struct ValueNameStruct*)
			malloc(sizeof(struct ValueNameStruct)))==NULL)
			return NULL;

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct ValueNameStruct));


		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		if(InsertTrie((TRIE**)&pTrie,pTemp->sValue,(void*)pTemp,
			assign_insert_trie)<0){
			WriteAlertMsg("加载表VALUE_NAME_%s错误",sMicro);
			return NULL;
		}

		if((++iCnt%10000)==0)
			WriteProcMsg("加载表VALUE_NAME_%s记录数%d",sMicro,iCnt);
	}

	WriteProcMsg("加载表VALUE_NAME_%s完毕总记录数%d",sMicro,iCnt);

	return pTrie;
}

int GetFormatIDByTemplateRuleID(int iTemplateRuleID)
{
	int iFormatID=0;
	
	EXEC SQL SELECT FORMAT_ID INTO :iFormatID
		FROM TEMPLATE_RULE
		WHERE TEMPLATE_RULE_ID=:iTemplateRuleID;
	
	if(CheckSqlResult("Get FormatID FROM TEMPLATE_RULE")<0) return -1;

	return iFormatID;
}
int GetTemplateIDByFormatID(int iFormatID)
{
	int iTemplateID=0;
	
	EXEC SQL SELECT TEMPLATE_ID INTO :iTemplateID
		FROM TAB_TEMPLATE
		WHERE FORMAT_ID=:iFormatID AND ROWNUM<2;
	
	if(CheckSqlResult("Get iTemplateID FROM TAB_TEMPLATE")<0) return -1;

	return iTemplateID;
}

/*批量数据动态从HOLIDAY中用结构缓冲方式取数据*/
int EGetHolidayToStruct(struct HolidayStruct *p,
	struct HolidayStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				to_char(DATES,'yyyymmddhh24miss'),\n\
				TYPE,\n\
				REMARK \n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE HOLIDAYSCR FROM :statement;
		CheckSqlError(" PREPARE HOLIDAYSCR HOLIDAYCR");

		EXEC SQL DECLARE HOLIDAYCR CURSOR FOR HOLIDAYSCR;
		CheckSqlError("Declare HOLIDAYCR");

		EXEC SQL OPEN HOLIDAYCR;
		CheckSqlError("Open HOLIDAYCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE HOLIDAYCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH HOLIDAYCR INTO
			:pSource->asDates,
			:pSource->asType,
			:pSource->asRemark;
		CheckSqlError("Fetch HOLIDAYCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE HOLIDAYCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=HOLIDAY_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sDates,	pSource->asDates[iCurPos]);
		strcpy(p->sType,	pSource->asType[iCurPos]);
		strcpy(p->sRemark,	pSource->asRemark[iCurPos]);
		
		AllTrim(p->sDates);
		AllTrim(p->sType);
		AllTrim(p->sRemark);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表HOLIDAY的链表释放函数**/
void DestroyHoliday(struct HolidayStruct *ptHead)
{
	struct HolidayStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitHoliday(struct HolidayStruct **pptHead)
{
	int iCnt=0;
	static struct HolidayStruct *pTemp,*ptHead=NULL;
	static struct HolidayStruct Temp;
	struct HolidayStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyHoliday(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct HolidayStructIn));
	sprintf(TempIn.sTableName,"HOLIDAY");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetHolidayToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct HolidayStruct*)
			malloc(sizeof(struct HolidayStruct)))==NULL){

			DestroyHoliday(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct HolidayStruct));


		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表HOLIDAY记录数%d",iCnt);
	}

	WriteProcMsg("加载表HOLIDAY完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从ACCT_ITEM中用结构缓冲方式取数据*/
int EGetAcctItemToStruct(struct AcctItemStruct *p,
	struct AcctItemStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				to_char(ACCT_ITEM_ID),\n\
				ACC_NBR,\n\
				ACCT_ITEM_TYPE_ID,\n\
				CHARGE,\n\
				AREA_CODE,\n\
				STATE,\n\
				nvl(BILLING_CYCLE_ID,0),\n\
				ACCT_TYPE,\n\
				to_char(nvl(ACCT_ITEM_DATE,SYSDATE+3000),'yyyymmddhh24miss'),\n\
				nvl(AUDIT_ITEM_TYPE_ID,'0'),\n\
				nvl(ACCT_ID,0),\n\
				nvl(DEFAULT_ACCT_ID,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE ACCT_ITEMSCR FROM :statement;
		CheckSqlError(" PREPARE ACCT_ITEMSCR ACCT_ITEMCR");

		EXEC SQL DECLARE ACCT_ITEMCR CURSOR FOR ACCT_ITEMSCR;
		CheckSqlError("Declare ACCT_ITEMCR");

		EXEC SQL OPEN ACCT_ITEMCR;
		CheckSqlError("Open ACCT_ITEMCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE ACCT_ITEMCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH ACCT_ITEMCR INTO
			:pSource->asAcctItemID,
			:pSource->asAccNbr,
			:pSource->aiAcctItemTypeID,
			:pSource->aiCharge,
			:pSource->asAreaCode,
			:pSource->asState,
			:pSource->aiBillingCycleID,
			:pSource->asAcctType,
			:pSource->asAcctItemDate,
			:pSource->aiAuditItemTypeID,
			:pSource->aiAcctID,
			:pSource->aiDefaultAcctID;
		CheckSqlError("Fetch ACCT_ITEMCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE ACCT_ITEMCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=ACCT_ITEM_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sAcctItemID,		pSource->asAcctItemID[iCurPos]);
		strcpy(p->sAccNbr,		pSource->asAccNbr[iCurPos]);

		p->iAcctItemTypeID=		pSource->aiAcctItemTypeID[iCurPos];
		p->iCharge=			pSource->aiCharge[iCurPos];

		strcpy(p->sAreaCode,		pSource->asAreaCode[iCurPos]);
		strcpy(p->sState,		pSource->asState[iCurPos]);

		p->iBillingCycleID=		pSource->aiBillingCycleID[iCurPos];

		strcpy(p->sAcctType,		pSource->asAcctType[iCurPos]);
		strcpy(p->sAcctItemDate,	pSource->asAcctItemDate[iCurPos]);
		p->iAuditItemTypeID=		pSource->aiAuditItemTypeID[iCurPos];
		p->iAcctID	=		pSource->aiAcctID[iCurPos];
		p->iDefaultAcctID	=	pSource->aiDefaultAcctID[iCurPos];
		
		AllTrim(p->sAcctItemID);
		AllTrim(p->sAccNbr);
		AllTrim(p->sAreaCode);
		AllTrim(p->sState);
		AllTrim(p->sAcctItemDate);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}

/*批量数据动态从TEMPLATE_ACCT_ITEM中用结构缓冲方式取数据*/
int EGetAcctItemAllFieldToStruct(struct AcctItemStruct *p,
	struct AcctItemAllFieldStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				to_char(ACCT_ITEM_ID),\n\
				ACC_NBR,\n\
				ACCT_ITEM_TYPE_ID,\n\
				CHARGE,\n\
				AREA_CODE,\n\
				STATE,\n\
				nvl(BILLING_CYCLE_ID,0),\n\
				to_char(nvl(ACCT_ITEM_DATE,SYSDATE+3000),'yyyymmddhh24miss'),\n\
				nvl(AUDIT_ITEM_TYPE_ID,0),\n\
				nvl(AUDIT_STATE,' '),\n\
				nvl(AUDIT_DETAIL_STATE,' '),\n\
				to_char(nvl(AUDIT_DATE,SYSDATE+3000),'yyyymmddhh24miss'),\n\
				nvl(AUDIT_DIFF_FEE,0),\n\
				nvl(AUDIT_INFO,' '),\n\
				nvl(ORI_ACCT_ITEM_ID,0),\n\
				nvl(AUDIT_BILLING_TYPE_ID,' '),\n\
				nvl(AUDIT_AREA_CODE,' '),\n\
				nvl(AUDIT_TARIFF_ID1,0),\n\
				nvl(AUDIT_TARIFF_ID2,0),\n\
				nvl(AUDIT_TARIFF_ID3,0),\n\
				nvl(AUDIT_FEE1,0),\n\
				nvl(AUDIT_FEE2,0),\n\
				nvl(AUDIT_FEE3,0),\n\
				nvl(AUDIT_ORI_FEE1,0),\n\
				nvl(AUDIT_ORI_FEE2,0),\n\
				nvl(AUDIT_ORI_FEE3,0),\n\
				nvl(AUDIT_TYPE1,' '),\n\
				nvl(AUDIT_TYPE2,' '),\n\
				nvl(AUDIT_TYPE3,' '),\n\
				ACCT_TYPE,\n\
				ACCT_ID,\n\
				nvl(DEFAULT_ACCT_ID,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE TEMPLATE_ACCT_ITEMSCR FROM :statement;
		CheckSqlError(" PREPARE TEMPLATE_ACCT_ITEMSCR TEMPLATE_ACCT_ITEMCR");

		EXEC SQL DECLARE TEMPLATE_ACCT_ITEMCR CURSOR FOR TEMPLATE_ACCT_ITEMSCR;
		CheckSqlError("Declare TEMPLATE_ACCT_ITEMCR");

		EXEC SQL OPEN TEMPLATE_ACCT_ITEMCR;
		CheckSqlError("Open TEMPLATE_ACCT_ITEMCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE TEMPLATE_ACCT_ITEMCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH TEMPLATE_ACCT_ITEMCR INTO
			:pSource->asAcctItemID,
			:pSource->asAccNbr,
			:pSource->aiAcctItemTypeID,
			:pSource->aiCharge,
			:pSource->asAreaCode,
			:pSource->asState,
			:pSource->aiBillingCycleID,
			:pSource->asAcctItemDate,
			:pSource->aiAuditItemTypeID,
			:pSource->asAuditState,
			:pSource->asAuditDetailState,
			:pSource->asAuditDate,
			:pSource->aiAuditDiffFee,
			:pSource->asAuditInfo,
			:pSource->asOriAcctItemID,
			:pSource->asAuditBillingTypeID,
			:pSource->asAuditAreaCode,
			:pSource->aiAuditTariffId1,
			:pSource->aiAuditTariffId2,
			:pSource->aiAuditTariffId3,
			:pSource->aiAuditFee1,
			:pSource->aiAuditFee2,
			:pSource->aiAuditFee3,
			:pSource->aiAuditOriFee1,
			:pSource->aiAuditOriFee2,
			:pSource->aiAuditOriFee3,
			:pSource->asAuditType1,
			:pSource->asAuditType2,
			:pSource->asAuditType3,
			:pSource->asAcctType,
			:pSource->aiAcctID,
			:pSource->aiDefaultAcctID;
		CheckSqlError("Fetch TEMPLATE_ACCT_ITEMCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE TEMPLATE_ACCT_ITEMCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=ACCT_ITEM_ALL_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sAcctItemID,		pSource->asAcctItemID[iCurPos]);
		strcpy(p->sAccNbr,		pSource->asAccNbr[iCurPos]);

		p->iAcctItemTypeID=		pSource->aiAcctItemTypeID[iCurPos];

		p->iCharge	=		pSource->aiCharge[iCurPos];
		strcpy(p->sAreaCode,		pSource->asAreaCode[iCurPos]);
		strcpy(p->sState,		pSource->asState[iCurPos]);

		p->iBillingCycleID=		pSource->aiBillingCycleID[iCurPos];

		strcpy(p->sAcctItemDate,	pSource->asAcctItemDate[iCurPos]);

		p->iAuditItemTypeID=		pSource->aiAuditItemTypeID[iCurPos];

		strcpy(p->sAuditState,		pSource->asAuditState[iCurPos]);
		strcpy(p->sAuditDetailState,	pSource->asAuditDetailState[iCurPos]);
		strcpy(p->sAuditDate,		pSource->asAuditDate[iCurPos]);
		
		p->iAuditDiffFee	=	pSource->aiAuditDiffFee[iCurPos];
		
		strcpy(p->sAuditInfo,		pSource->asAuditInfo[iCurPos]);
		
		strcpy(p->sOriAcctItemID,	pSource->asOriAcctItemID[iCurPos]);
		
		strcpy(p->sAuditBillingTypeID,	pSource->asAuditBillingTypeID[iCurPos]);
		strcpy(p->sAuditAreaCode,	pSource->asAuditAreaCode[iCurPos]);

		p->iAuditTariffId1=		pSource->aiAuditTariffId1[iCurPos];
		p->iAuditTariffId2=		pSource->aiAuditTariffId2[iCurPos];
		p->iAuditTariffId3=		pSource->aiAuditTariffId3[iCurPos];

		p->iAuditFee1	=		pSource->aiAuditFee1[iCurPos];
		p->iAuditFee2	=		pSource->aiAuditFee2[iCurPos];
		p->iAuditFee3	=		pSource->aiAuditFee3[iCurPos];
		p->iAuditOriFee1=		pSource->aiAuditOriFee1[iCurPos];
		p->iAuditOriFee2=		pSource->aiAuditOriFee2[iCurPos];
		p->iAuditOriFee3=		pSource->aiAuditOriFee3[iCurPos];
		
		strcpy(p->sAuditType1,		pSource->asAuditType1[iCurPos]);
		strcpy(p->sAuditType2,		pSource->asAuditType2[iCurPos]);
		strcpy(p->sAuditType3,		pSource->asAuditType3[iCurPos]);
		strcpy(p->sAcctType,		pSource->asAcctType[iCurPos]);

		p->iAcctID=			pSource->aiAcctID[iCurPos];
		p->iDefaultAcctID=		pSource->aiDefaultAcctID[iCurPos];

		AllTrim(p->sAcctItemID);
		AllTrim(p->sAccNbr);
		AllTrim(p->sAreaCode);
		AllTrim(p->sState);
		AllTrim(p->sAcctItemDate);
		AllTrim(p->sAuditState);
		AllTrim(p->sAuditDetailState);
		AllTrim(p->sAuditDate);
		AllTrim(p->sAuditInfo);
		AllTrim(p->sOriAcctItemID);
		AllTrim(p->sAuditBillingTypeID);
		AllTrim(p->sAuditAreaCode);
		AllTrim(p->sAuditType1);
		AllTrim(p->sAuditType2);
		AllTrim(p->sAuditType3);
		AllTrim(p->sAcctType);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}

/*批量数据结构缓冲写入ACCT_ITEM*/
int EInsertStructToAcctItem(struct AcctItemStruct *p,
	int iInsertFlag,struct AcctItemStructOut *pTarget)
{

	int  iCurPos=pTarget->iCurPos;
	char *sTableName=pTarget->sTableName;

	if(iInsertFlag!=TRUE){

/*放置数据到静态缓冲*/
		strcpy(pTarget->asAcctItemID[iCurPos],		p->sAcctItemID);
		strcpy(pTarget->asAccNbr[iCurPos],		p->sAccNbr);

		pTarget->aiAcctItemTypeID[iCurPos]=		p->iAcctItemTypeID;
		pTarget->aiCharge[iCurPos]=			p->iCharge;

		strcpy(pTarget->asAreaCode[iCurPos],		p->sAreaCode);
		strcpy(pTarget->asState[iCurPos],		p->sState);

		pTarget->aiBillingCycleID[iCurPos]=		p->iBillingCycleID;

		strcpy(pTarget->asAcctItemDate[iCurPos],	p->sAcctItemDate);
		strcpy(pTarget->asAcctType[iCurPos],		p->sAcctType);
	
		pTarget->aiAuditItemTypeID[iCurPos]=		p->iAuditItemTypeID;
		
		pTarget->aiAcctID[iCurPos]	=		p->iAcctID;
		pTarget->aiDefaultAcctID[iCurPos]	=	p->iDefaultAcctID;

		strcpy(pTarget->asAuditState[iCurPos],		p->sAuditState);
		strcpy(pTarget->asAuditDetailState[iCurPos],	p->sAuditDetailState);
		strcpy(pTarget->asAuditDate[iCurPos],		p->sAuditDate);

		pTarget->aiAuditDiffFee[iCurPos]=		p->iAuditDiffFee;

		strcpy(pTarget->asAuditInfo[iCurPos],		p->sAuditInfo);
		strcpy(pTarget->asOriAcctItemID[iCurPos],	p->sOriAcctItemID);
		strcpy(pTarget->asAuditBillingTypeID[iCurPos],	p->sAuditBillingTypeID);
		strcpy(pTarget->asAuditAreaCode[iCurPos],	p->sAuditAreaCode);

		pTarget->aiAuditTariffId1[iCurPos]=		p->iAuditTariffId1;
		pTarget->aiAuditTariffId2[iCurPos]=		p->iAuditTariffId2;
		pTarget->aiAuditTariffId3[iCurPos]=		p->iAuditTariffId3;
		pTarget->aiAuditFee1[iCurPos]=			p->iAuditFee1;
		pTarget->aiAuditFee2[iCurPos]=			p->iAuditFee2;
		pTarget->aiAuditFee3[iCurPos]=			p->iAuditFee3;
		pTarget->aiAuditOriFee1[iCurPos]=		p->iAuditOriFee1;
		pTarget->aiAuditOriFee2[iCurPos]=		p->iAuditOriFee2;
		pTarget->aiAuditOriFee3[iCurPos]=		p->iAuditOriFee3;

		strcpy(pTarget->asAuditType1[iCurPos],		p->sAuditType1);
		strcpy(pTarget->asAuditType2[iCurPos],		p->sAuditType2);
		strcpy(pTarget->asAuditType3[iCurPos],		p->sAuditType3);

		iCurPos++;

	}

	if(iInsertFlag==TRUE||iCurPos==ACCT_ITEM_BUFLEN_OUT){

/* INSERT */
		char statement[8192];

		if(iCurPos==0) return 0;

		sprintf(statement,"\n\
			INSERT INTO %s(\n\
				ACCT_ITEM_ID,\n\
				ACC_NBR,\n\
				ACCT_ITEM_TYPE_ID,\n\
				CHARGE,\n\
				AREA_CODE,\n\
				STATE,\n\
				BILLING_CYCLE_ID,\n\
				ACCT_TYPE,\n\
				ACCT_ITEM_DATE,\n\
				ACCT_ID,\n\
				DEFAULT_ACCT_ID,\n\
				AUDIT_ITEM_TYPE_ID,\n\
				AUDIT_STATE,\n\
				AUDIT_DETAIL_STATE,\n\
				AUDIT_DATE,\n\
				AUDIT_DIFF_FEE,\n\
				AUDIT_INFO,\n\
				ORI_ACCT_ITEM_ID,\n\
				AUDIT_BILLING_TYPE_ID,\n\
				AUDIT_AREA_CODE,\n\
				AUDIT_TARIFF_ID1,\n\
				AUDIT_TARIFF_ID2,\n\
				AUDIT_TARIFF_ID3,\n\
				AUDIT_FEE1,\n\
				AUDIT_FEE2,\n\
				AUDIT_FEE3,\n\
				AUDIT_ORI_FEE1,\n\
				AUDIT_ORI_FEE2,\n\
				AUDIT_ORI_FEE3,\n\
				AUDIT_TYPE1,\n\
				AUDIT_TYPE2,\n\
				AUDIT_TYPE3)\n\
			VALUES (\n\
				to_number(:asAcctItemID),\n\
				:asAccNbr,\n\
				:aiAcctItemTypeID,\n\
				:aiCharge,\n\
				:asAreaCode,\n\
				:asState,\n\
				:aiBillingCycleID,\n\
				:asAcctType,\n\
				to_date(:asAcctItemDate,'yyyymmddhh24miss'),\n\
				:aiAcctID,\n\
				:aiDefaultAcctID,\n\
				:aiAuditItemTypeID,\n\
				:asAuditState,\n\
				:asAuditDetailState,\n\
				to_date(:asAuditDate,'yyyymmddhh24miss'),\n\
				:aiAuditDiffFee,\n\
				:asAuditInfo,\n\
				to_number(:asOriAcctItemID),\n\
				:asAuditBillingTypeID,\n\
				:asAuditAreaCode,\n\
				:aiAuditTariffId1,\n\
				:aiAuditTariffId2,\n\
				:aiAuditTariffId3,\n\
				:aiAuditFee1,\n\
				:aiAuditFee2,\n\
				:aiAuditFee3,\n\
				:aiAuditOriFee1,\n\
				:aiAuditOriFee2,\n\
				:aiAuditOriFee3,\n\
				:asAuditType1,\n\
				:asAuditType2,\n\
				:asAuditType3\n\
			)",sTableName);



		EXEC SQL PREPARE ACCT_ITEMTRG FROM :statement;
		if(CheckSqlResult("Prepare insert statement ACCT_ITEM")<0) return -1;

		EXEC SQL FOR :iCurPos EXECUTE ACCT_ITEMTRG USING
				:pTarget->asAcctItemID,
				:pTarget->asAccNbr,
				:pTarget->aiAcctItemTypeID,
				:pTarget->aiCharge,
				:pTarget->asAreaCode,
				:pTarget->asState,
				:pTarget->aiBillingCycleID,
				:pTarget->asAcctType,
				:pTarget->asAcctItemDate,
				:pTarget->aiAcctID,
				:pTarget->aiDefaultAcctID,
				:pTarget->aiAuditItemTypeID,
				:pTarget->asAuditState,
				:pTarget->asAuditDetailState,
				:pTarget->asAuditDate,
				:pTarget->aiAuditDiffFee,
				:pTarget->asAuditInfo,
				:pTarget->asOriAcctItemID,
				:pTarget->asAuditBillingTypeID,
				:pTarget->asAuditAreaCode,
				:pTarget->aiAuditTariffId1,
				:pTarget->aiAuditTariffId2,
				:pTarget->aiAuditTariffId3,
				:pTarget->aiAuditFee1,
				:pTarget->aiAuditFee2,
				:pTarget->aiAuditFee3,
				:pTarget->aiAuditOriFee1,
				:pTarget->aiAuditOriFee2,
				:pTarget->aiAuditOriFee3,
				:pTarget->asAuditType1,
				:pTarget->asAuditType2,
				:pTarget->asAuditType3;

		if(CheckSqlResult("Dyn insert into ACCT_ITEM")<0) return -1;

		iCurPos=0;
	}

	pTarget->iCurPos=iCurPos;
	return 0;
}

/*批量数据动态从AUDIT_PARAM中用结构缓冲方式取数据*/
int EGetAuditParamToStruct(struct AuditParamStruct *p,
	struct AuditParamStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				SERVICE_TYPE,\n\
				AUDIT_TYPE,\n\
				SEQ,\n\
				AUDIT_TABLE_NAME,\n\
				TABLE_TYPE,\n\
				TEMPLATE_RULE_ID,\n\
				nvl(PART_SPLIT_TYPE,' '),\n\
				TEMPLATE_ID,\n\
				FORMAT_ID,\n\
				STATE,\n\
				CR_RULE_ID\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE AUDIT_PARAMSCR FROM :statement;
		CheckSqlError(" PREPARE AUDIT_PARAMSCR AUDIT_PARAMCR");

		EXEC SQL DECLARE AUDIT_PARAMCR CURSOR FOR AUDIT_PARAMSCR;
		CheckSqlError("Declare AUDIT_PARAMCR");

		EXEC SQL OPEN AUDIT_PARAMCR;
		CheckSqlError("Open AUDIT_PARAMCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE AUDIT_PARAMCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH AUDIT_PARAMCR INTO
			:pSource->asServiceType,
			:pSource->asAuditType,
			:pSource->aiSeq,
			:pSource->asAuditTableName,
			:pSource->asTableType,
			:pSource->aiTemplateRuleID,
			:pSource->asPartSplitType,
			:pSource->aiTemplateID,
			:pSource->aiFormatID,
			:pSource->asState,
			:pSource->aiCrRuleID;
		CheckSqlError("Fetch AUDIT_PARAMCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE AUDIT_PARAMCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=AUDIT_PARAM_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sServiceType,		pSource->asServiceType[iCurPos]);
		strcpy(p->sAuditType,		pSource->asAuditType[iCurPos]);
		strcpy(p->sAuditTableName,	pSource->asAuditTableName[iCurPos]);
		strcpy(p->sTableType,		pSource->asTableType[iCurPos]);

		p->iSeq=			pSource->aiSeq[iCurPos];
		p->iTemplateRuleID=		pSource->aiTemplateRuleID[iCurPos];

		strcpy(p->sPartSplitType,	pSource->asPartSplitType[iCurPos]);

		p->iTemplateID=			pSource->aiTemplateID[iCurPos];
		p->iFormatID=			pSource->aiFormatID[iCurPos];
		
		strcpy(p->sState,		pSource->asState[iCurPos]);
		
		p->iCrRuleID=			pSource->aiCrRuleID[iCurPos];
		
		AllTrim(p->sServiceType);
		AllTrim(p->sAuditType);
		AllTrim(p->sAuditTableName);
		AllTrim(p->sTableType);
		AllTrim(p->sPartSplitType);
		AllTrim(p->sState);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}

/**对表AUDIT_PARAM的链表释放函数**/
void DestroyAuditParam(struct AuditParamStruct *ptHead)
{
	struct AuditParamStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitAuditParam(struct AuditParamStruct **pptHead,char sAuditType[])
{
	int iCnt=0;
	static struct AuditParamStruct *pTemp,*ptHead=NULL;
	struct AuditParamStruct Temp;
	struct AuditParamStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyAuditParam(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct AuditParamStructIn));
	sprintf(TempIn.sTableName,"AUDIT_PARAM");
	sprintf(TempIn.sCondition,"WHERE AUDIT_TYPE='%s' AND STATE='0'",sAuditType);
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetAuditParamToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct AuditParamStruct*)
			malloc(sizeof(struct AuditParamStruct)))==NULL){

			DestroyAuditParam(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct AuditParamStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表AUDIT_PARAM记录数%d",iCnt);
	}

	WriteProcMsg("加载表AUDIT_PARAM完毕总记录数%d",iCnt);

	return iCnt;
}
/*批量数据动态从AUDIT_ITEM_TYPE中用结构缓冲方式取数据*/
int EGetAuditItemTypeToStruct(struct AuditItemTypeStruct *p,
	struct AuditItemTypeStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				AUDIT_ITEM_TYPE_ID,\n\
				nvl(NAME,' ')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE AUDIT_ITEM_TYPESCR FROM :statement;
		CheckSqlError(" PREPARE AUDIT_ITEM_TYPESCR AUDIT_ITEM_TYPECR");

		EXEC SQL DECLARE AUDIT_ITEM_TYPECR CURSOR FOR AUDIT_ITEM_TYPESCR;
		CheckSqlError("Declare AUDIT_ITEM_TYPECR");

		EXEC SQL OPEN AUDIT_ITEM_TYPECR;
		CheckSqlError("Open AUDIT_ITEM_TYPECR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE AUDIT_ITEM_TYPECR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH AUDIT_ITEM_TYPECR INTO
			:pSource->aiAuditItemTypeID,
			:pSource->asName;
		CheckSqlError("Fetch AUDIT_ITEM_TYPECR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE AUDIT_ITEM_TYPECR;

			return FALSE;
		}

		if(pSource->iRecCnt!=AUDIT_ITEM_TYPE_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iAuditItemTypeID=	pSource->aiAuditItemTypeID[iCurPos];

		strcpy(p->sName,	pSource->asName[iCurPos]);

		AllTrim(p->sName);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表AUDIT_ITEM_TYPE的链表释放函数**/
void DestroyAuditItemType(struct AuditItemTypeStruct *ptHead)
{
	struct AuditItemTypeStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitAuditItemType(struct AuditItemTypeStruct **pptHead)
{
	int iCnt=0;
	static struct AuditItemTypeStruct *pTemp,*ptHead=NULL;
	struct AuditItemTypeStruct Temp;
	struct AuditItemTypeStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyAuditItemType(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct AuditItemTypeStructIn));
	sprintf(TempIn.sTableName,"AUDIT_ITEM_TYPE");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetAuditItemTypeToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct AuditItemTypeStruct*)
			malloc(sizeof(struct AuditItemTypeStruct)))==NULL){

			DestroyAuditItemType(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct AuditItemTypeStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表AUDIT_ITEM_TYPE记录数%d",iCnt);
	}

	WriteProcMsg("加载表AUDIT_ITEM_TYPE完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从AUDIT_ITEM_RELATION中用结构缓冲方式取数据*/
int EGetAuditItemRelationToStruct(struct AuditItemRelationStruct *p,
	struct AuditItemRelationStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				ACCT_ITEM_TYPE_ID,\n\
				AUDIT_ITEM_TYPE_ID\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE AUDIT_ITEM_RELATIONSCR FROM :statement;
		CheckSqlError(" PREPARE AUDIT_ITEM_RELATIONSCR AUDIT_ITEM_RELATIONCR");

		EXEC SQL DECLARE AUDIT_ITEM_RELATIONCR CURSOR FOR AUDIT_ITEM_RELATIONSCR;
		CheckSqlError("Declare AUDIT_ITEM_RELATIONCR");

		EXEC SQL OPEN AUDIT_ITEM_RELATIONCR;
		CheckSqlError("Open AUDIT_ITEM_RELATIONCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE AUDIT_ITEM_RELATIONCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH AUDIT_ITEM_RELATIONCR INTO
			:pSource->aiAcctItemTypeID,
			:pSource->aiAuditItemTypeID;
		CheckSqlError("Fetch AUDIT_ITEM_RELATIONCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE AUDIT_ITEM_RELATIONCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=AUDIT_ITEM_RELATION_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iAcctItemTypeID=	pSource->aiAcctItemTypeID[iCurPos];
		p->iAuditItemTypeID=	pSource->aiAuditItemTypeID[iCurPos];


	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表AUDIT_ITEM_RELATION的链表释放函数**/
void DestroyAuditItemRelation(struct AuditItemRelationStruct *ptHead)
{
	struct AuditItemRelationStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitAuditItemRelation(struct AuditItemRelationStruct **pptHead)
{
	int iCnt=0;
	static struct AuditItemRelationStruct *pTemp,*ptHead=NULL;
	struct AuditItemRelationStruct Temp;
	struct AuditItemRelationStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyAuditItemRelation(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct AuditItemRelationStructIn));
	sprintf(TempIn.sTableName,"AUDIT_ITEM_RELATION");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetAuditItemRelationToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct AuditItemRelationStruct*)
			malloc(sizeof(struct AuditItemRelationStruct)))==NULL){

			DestroyAuditItemRelation(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct AuditItemRelationStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表AUDIT_ITEM_RELATION记录数%d",iCnt);
	}

	WriteProcMsg("加载表AUDIT_ITEM_RELATION完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从TEMPLATE_MSISDN_PARAM中用结构缓冲方式取数据*/
int EGetTemplateMsisdnParamToStruct(struct TemplateMsisdnParamStruct *p,
	struct TemplateMsisdnParamStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(MSISDN,' '),\n\
				nvl(PARAM_CODE,' '),\n\
				nvl(PARAM_VALUE,' '),\n\
				nvl(BILLING_MONTH,' ')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE TEMPLATE_MSISDN_PARAMSCR FROM :statement;
		CheckSqlError(" PREPARE TEMPLATE_MSISDN_PARAMSCR TEMPLATE_MSISDN_PARAMCR");

		EXEC SQL DECLARE TEMPLATE_MSISDN_PARAMCR CURSOR FOR TEMPLATE_MSISDN_PARAMSCR;
		CheckSqlError("Declare TEMPLATE_MSISDN_PARAMCR");

		EXEC SQL OPEN TEMPLATE_MSISDN_PARAMCR;
		CheckSqlError("Open TEMPLATE_MSISDN_PARAMCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE TEMPLATE_MSISDN_PARAMCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH TEMPLATE_MSISDN_PARAMCR INTO
			:pSource->asMsisdn,
			:pSource->asParamCode,
			:pSource->asParamValue,
			:pSource->asBillingMonth;
		CheckSqlError("Fetch TEMPLATE_MSISDN_PARAMCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE TEMPLATE_MSISDN_PARAMCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=TEMPLATE_MSISDN_PARAM_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sMsisdn,		pSource->asMsisdn[iCurPos]);
		strcpy(p->sParamCode,		pSource->asParamCode[iCurPos]);
		strcpy(p->sParamValue,		pSource->asParamValue[iCurPos]);
		strcpy(p->sBillingMonth,	pSource->asBillingMonth[iCurPos]);

		AllTrim(p->sMsisdn);
		AllTrim(p->sParamCode);
		AllTrim(p->sParamValue);
		AllTrim(p->sBillingMonth);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表TEMPLATE_MSISDN_PARAM的链表释放函数**/
void DestroyTemplateMsisdnParam(struct TemplateMsisdnParamStruct *ptHead)
{
	struct TemplateMsisdnParamStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
/*批量数据动态从PARAM_CODE_DESC中用结构缓冲方式取数据*/
int EGetParamCodeDescToStruct(struct ParamCodeDescStruct *p,
	struct ParamCodeDescStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(PARAM_CODE,' '),\n\
				nvl(BILLING_TYPE_ID,' '),\n\
				nvl(REMARK,' ')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE PARAM_CODE_DESCSCR FROM :statement;
		CheckSqlError(" PREPARE PARAM_CODE_DESCSCR PARAM_CODE_DESCCR");

		EXEC SQL DECLARE PARAM_CODE_DESCCR CURSOR FOR PARAM_CODE_DESCSCR;
		CheckSqlError("Declare PARAM_CODE_DESCCR");

		EXEC SQL OPEN PARAM_CODE_DESCCR;
		CheckSqlError("Open PARAM_CODE_DESCCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE PARAM_CODE_DESCCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH PARAM_CODE_DESCCR INTO
			:pSource->asParamCode,
			:pSource->asBillingTypeID,
			:pSource->asRemark;
		CheckSqlError("Fetch PARAM_CODE_DESCCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE PARAM_CODE_DESCCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=PARAM_CODE_DESC_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sParamCode,		pSource->asParamCode[iCurPos]);
		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);
		strcpy(p->sRemark,		pSource->asRemark[iCurPos]);

		AllTrim(p->sParamCode);
		AllTrim(p->sBillingTypeID);
		AllTrim(p->sRemark);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表PARAM_CODE_DESC的链表释放函数**/
void DestroyParamCodeDesc(struct ParamCodeDescStruct *ptHead)
{
	struct ParamCodeDescStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}

/*获取ACCT_ITEM_ID序列号*/
int GetAcctItemIDSeq()
{
	int iAcctItemIDSeq=0;
	
	EXEC SQL SELECT ACCT_ITEM_ID_SEQ.nextval INTO :iAcctItemIDSeq FROM DUAL ;
	CheckSqlError("Get ACCT_ITEM_ID_SEQ ERROR");
	
	return iAcctItemIDSeq;
	
}

/*批量数据动态从BAS_MSISDN中用结构缓冲方式取数据*/
int EGetBasMsisdnToStruct(struct BasMsisdnStruct *p,
	struct BasMsisdnStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(MSISDN,' '),\n\
				nvl(CNT,0),\n\
				SUBSCRIPTION_ID\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE BAS_MSISDNSCR FROM :statement;
		CheckSqlError(" PREPARE BAS_MSISDNSCR BAS_MSISDNCR");

		EXEC SQL DECLARE BAS_MSISDNCR CURSOR FOR BAS_MSISDNSCR;
		CheckSqlError("Declare BAS_MSISDNCR");

		EXEC SQL OPEN BAS_MSISDNCR;
		CheckSqlError("Open BAS_MSISDNCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE BAS_MSISDNCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH BAS_MSISDNCR INTO
			:pSource->asMsisdn,
			:pSource->aiCnt,
			:pSource->aiSubscriptionID;
		CheckSqlError("Fetch BAS_MSISDNCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE BAS_MSISDNCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=BAS_MSISDN_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sMsisdn,	pSource->asMsisdn[iCurPos]);

		p->iCnt=		pSource->aiCnt[iCurPos];
		p->iSubscriptionID=	pSource->aiSubscriptionID[iCurPos];

		AllTrim(p->sMsisdn);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表BAS_MSISDN的链表释放函数**/
void DestroyBasMsisdn(struct BasMsisdnStruct *ptHead)
{
	struct BasMsisdnStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}

int InitBasMsisdn(char sTableName[],struct BasMsisdnStruct **pptHead)
{
	int iCnt=0;
	static struct BasMsisdnStruct *pTemp,*ptHead=NULL;
	struct BasMsisdnStruct Temp;
	struct BasMsisdnStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyBasMsisdn(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct BasMsisdnStructIn));
	/*sprintf(TempIn.sTableName,"BAS_MSISDN");*/
	strcpy(TempIn.sTableName,sTableName);
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetBasMsisdnToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct BasMsisdnStruct*)
			malloc(sizeof(struct BasMsisdnStruct)))==NULL){

			DestroyBasMsisdn(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct BasMsisdnStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表BAS_MSISDN记录数%d",iCnt);
	}

	WriteProcMsg("加载表BAS_MSISDN完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从PROMISE_EXPR_PARAM中用结构缓冲方式取数据*/
int EGetPromiseExprParamToStruct(struct PromiseExprParamStruct *p,
	struct PromiseExprParamStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(BILLING_TYPE_ID,' '),\n\
				nvl(EXPR_ID,0),\n\
				nvl(PARAM_CNT,0),\n\
				nvl(PARAM_VALUE,' '),\n\
				nvl(RATE_METHOD,' '),\n\
				nvl(PARAM_ID,0),\n\
				nvl(F_PARAM_FMT,' ')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE PROMISE_EXPR_PARAMSCR FROM :statement;
		CheckSqlError(" PREPARE PROMISE_EXPR_PARAMSCR PROMISE_EXPR_PARAMCR");

		EXEC SQL DECLARE PROMISE_EXPR_PARAMCR CURSOR FOR PROMISE_EXPR_PARAMSCR;
		CheckSqlError("Declare PROMISE_EXPR_PARAMCR");

		EXEC SQL OPEN PROMISE_EXPR_PARAMCR;
		CheckSqlError("Open PROMISE_EXPR_PARAMCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE PROMISE_EXPR_PARAMCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH PROMISE_EXPR_PARAMCR INTO
			:pSource->asBillingTypeID,
			:pSource->aiExprID,
			:pSource->aiParamCnt,
			:pSource->asParamValue,
			:pSource->asRateMethod,
			:pSource->aiParamID,
			:pSource->asFParamFmt;
		CheckSqlError("Fetch PROMISE_EXPR_PARAMCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE PROMISE_EXPR_PARAMCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=PROMISE_EXPR_PARAM_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);

		p->iExprID=			pSource->aiExprID[iCurPos];
		p->iParamCnt=			pSource->aiParamCnt[iCurPos];

		strcpy(p->sParamValue,		pSource->asParamValue[iCurPos]);
		strcpy(p->sRateMethod,		pSource->asRateMethod[iCurPos]);

		p->iParamID=			pSource->aiParamID[iCurPos];

		strcpy(p->sFParamFmt,		pSource->asFParamFmt[iCurPos]);

		AllTrim(p->sBillingTypeID);
		AllTrim(p->sParamValue);
		AllTrim(p->sRateMethod);
		AllTrim(p->sFParamFmt);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表PROMISE_EXPR_PARAM的链表释放函数**/
void DestroyPromiseExprParam(struct PromiseExprParamStruct *ptHead)
{
	struct PromiseExprParamStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitPromiseExprParam(struct PromiseExprParamStruct **pptHead)
{
	int iCnt=0;
	static struct PromiseExprParamStruct *pTemp,*ptHead=NULL;
	struct PromiseExprParamStruct Temp;
	struct PromiseExprParamStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyPromiseExprParam(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct PromiseExprParamStructIn));
	sprintf(TempIn.sTableName,"PROMISE_EXPR_PARAM");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetPromiseExprParamToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct PromiseExprParamStruct*)
			malloc(sizeof(struct PromiseExprParamStruct)))==NULL){

			DestroyPromiseExprParam(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct PromiseExprParamStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表PROMISE_EXPR_PARAM记录数%d",iCnt);
	}

	WriteProcMsg("加载表PROMISE_EXPR_PARAM完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从PROMISE_EXPR_MSISDN_PARAM中用结构缓冲方式取数据*/
int EGetPromiseExprMsisdnParamToStruct(struct PromiseExprMsisdnParamStruct *p,
	struct PromiseExprMsisdnParamStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(BILLING_TYPE_ID,' '),\n\
				nvl(PARAM_CNT,0),\n\
				nvl(PARAM_VALUE,' '),\n\
				nvl(MSISDN,' '),\n\
				to_char(nvl(ACTIVE_DATE,SYSDATE+3000),'yyyymmddhh24miss'),\n\
				to_char(nvl(INACTIVE_DATE,SYSDATE+3000),'yyyymmddhh24miss')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE PROMISE_EXPR_MSISDN_PARAMSCR FROM :statement;
		CheckSqlError(" PREPARE PROMISE_EXPR_MSISDN_PARAMSCR PROMISE_EXPR_MSISDN_PARAMCR");

		EXEC SQL DECLARE PROMISE_EXPR_MSISDN_PARAMCR CURSOR FOR PROMISE_EXPR_MSISDN_PARAMSCR;
		CheckSqlError("Declare PROMISE_EXPR_MSISDN_PARAMCR");

		EXEC SQL OPEN PROMISE_EXPR_MSISDN_PARAMCR;
		CheckSqlError("Open PROMISE_EXPR_MSISDN_PARAMCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE PROMISE_EXPR_MSISDN_PARAMCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH PROMISE_EXPR_MSISDN_PARAMCR INTO
			:pSource->asBillingTypeID,
			:pSource->aiParamCnt,
			:pSource->asParamValue,
			:pSource->asMsisdn,
			:pSource->asActiveDate,
			:pSource->asInactiveDate;
		CheckSqlError("Fetch PROMISE_EXPR_MSISDN_PARAMCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE PROMISE_EXPR_MSISDN_PARAMCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=PROMISE_EXPR_MSISDN_PARAM_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);

		p->iParamCnt=			pSource->aiParamCnt[iCurPos];

		strcpy(p->sParamValue,		pSource->asParamValue[iCurPos]);
		strcpy(p->sMsisdn,		pSource->asMsisdn[iCurPos]);
		strcpy(p->sActiveDate,		pSource->asActiveDate[iCurPos]);
		strcpy(p->sInactiveDate,	pSource->asInactiveDate[iCurPos]);

		AllTrim(p->sBillingTypeID);
		AllTrim(p->sParamValue);
		AllTrim(p->sMsisdn);
		AllTrim(p->sActiveDate);
		AllTrim(p->sInactiveDate);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表PROMISE_EXPR_MSISDN_PARAM的链表释放函数**/
void DestroyPromiseExprMsisdnParam(struct PromiseExprMsisdnParamStruct *ptHead)
{
	struct PromiseExprMsisdnParamStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitPromiseExprMsisdnParam(struct PromiseExprMsisdnParamStruct **pptHead)
{
	int iCnt=0;
	static struct PromiseExprMsisdnParamStruct *pTemp,*ptHead=NULL;
	struct PromiseExprMsisdnParamStruct Temp;
	struct PromiseExprMsisdnParamStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyPromiseExprMsisdnParam(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct PromiseExprMsisdnParamStructIn));
	sprintf(TempIn.sTableName,"PROMISE_EXPR_MSISDN_PARAM");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetPromiseExprMsisdnParamToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct PromiseExprMsisdnParamStruct*)
			malloc(sizeof(struct PromiseExprMsisdnParamStruct)))==NULL){

			DestroyPromiseExprMsisdnParam(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct PromiseExprMsisdnParamStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表PROMISE_EXPR_MSISDN_PARAM记录数%d",iCnt);
	}

	WriteProcMsg("加载表PROMISE_EXPR_MSISDN_PARAM完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从PROMISE_EXPR中用结构缓冲方式取数据*/
int EGetPromiseExprToStruct(struct PromiseExprStruct *p,
	struct PromiseExprStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(EXPR_ID,0),\n\
				nvl(PARAM_NAME_STR,' '),\n\
				nvl(REMARK,' '),\n\
				nvl(EXPR,' '),\n\
				nvl(PROMISE_TYPE,'D'),\n\
				nvl(NAME,' ')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE PROMISE_EXPRSCR FROM :statement;
		CheckSqlError(" PREPARE PROMISE_EXPRSCR PROMISE_EXPRCR");

		EXEC SQL DECLARE PROMISE_EXPRCR CURSOR FOR PROMISE_EXPRSCR;
		CheckSqlError("Declare PROMISE_EXPRCR");

		EXEC SQL OPEN PROMISE_EXPRCR;
		CheckSqlError("Open PROMISE_EXPRCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE PROMISE_EXPRCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH PROMISE_EXPRCR INTO
			:pSource->aiExprID,
			:pSource->asParamNameStr,
			:pSource->asRemark,
			:pSource->asExpr,
			:pSource->asPromiseType,
			:pSource->asName;
		CheckSqlError("Fetch PROMISE_EXPRCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE PROMISE_EXPRCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=PROMISE_EXPR_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iExprID=			pSource->aiExprID[iCurPos];

		strcpy(p->sParamNameStr,	pSource->asParamNameStr[iCurPos]);
		strcpy(p->sRemark,		pSource->asRemark[iCurPos]);
		strcpy(p->sExpr,		pSource->asExpr[iCurPos]);
		strcpy(p->sPromiseType,		pSource->asPromiseType[iCurPos]);
		strcpy(p->sName,		pSource->asName[iCurPos]);

		AllTrim(p->sParamNameStr);
		AllTrim(p->sRemark);
		AllTrim(p->sExpr);
		AllTrim(p->sPromiseType);
		AllTrim(p->sName);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表PROMISE_EXPR的链表释放函数**/
void DestroyPromiseExpr(struct PromiseExprStruct *ptHead)
{
	struct PromiseExprStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitPromiseExpr(struct PromiseExprStruct **pptHead)
{
	int iCnt=0;
	static struct PromiseExprStruct *pTemp,*ptHead=NULL;
	struct PromiseExprStruct Temp;
	struct PromiseExprStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyPromiseExpr(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct PromiseExprStructIn));
	sprintf(TempIn.sTableName,"PROMISE_EXPR");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetPromiseExprToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct PromiseExprStruct*)
			malloc(sizeof(struct PromiseExprStruct)))==NULL){

			DestroyPromiseExpr(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct PromiseExprStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表PROMISE_EXPR记录数%d",iCnt);
	}

	WriteProcMsg("加载表PROMISE_EXPR完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从MONTH_FEE_TARIFF中用结构缓冲方式取数据*/
int EGetMonthFeeTariffToStruct(struct MonthFeeTariffStruct *p,
	struct MonthFeeTariffStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(BILLING_TYPE_ID,' '),\n\
				nvl(AREA_CODE,'*'),\n\
				nvl(TYPE,'Z'),\n\
				nvl(UNIT,'M'),\n\
				nvl(HALF_MONTH_FLAG,'0'),\n\
				nvl(RATE,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE MONTH_FEE_TARIFFSCR FROM :statement;
		CheckSqlError(" PREPARE MONTH_FEE_TARIFFSCR MONTH_FEE_TARIFFCR");

		EXEC SQL DECLARE MONTH_FEE_TARIFFCR CURSOR FOR MONTH_FEE_TARIFFSCR;
		CheckSqlError("Declare MONTH_FEE_TARIFFCR");

		EXEC SQL OPEN MONTH_FEE_TARIFFCR;
		CheckSqlError("Open MONTH_FEE_TARIFFCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE MONTH_FEE_TARIFFCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH MONTH_FEE_TARIFFCR INTO
			:pSource->asBillingTypeID,
			:pSource->asAreaCode,
			:pSource->asType,
			:pSource->asUnit,
			:pSource->asHalfMonthFlag,
			:pSource->adRate;
		CheckSqlError("Fetch MONTH_FEE_TARIFFCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE MONTH_FEE_TARIFFCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=MONTH_FEE_TARIFF_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);
		strcpy(p->sAreaCode,		pSource->asAreaCode[iCurPos]);
		strcpy(p->sType,		pSource->asType[iCurPos]);
		strcpy(p->sUnit,		pSource->asUnit[iCurPos]);
		strcpy(p->sHalfMonthFlag,	pSource->asHalfMonthFlag[iCurPos]);

		p->dRate=			pSource->adRate[iCurPos];

		AllTrim(p->sBillingTypeID);
		AllTrim(p->sAreaCode);
		AllTrim(p->sType);
		AllTrim(p->sUnit);
		AllTrim(p->sHalfMonthFlag);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表MONTH_FEE_TARIFF的链表释放函数**/
void DestroyMonthFeeTariff(struct MonthFeeTariffStruct *ptHead)
{
	struct MonthFeeTariffStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitMonthFeeTariff(struct MonthFeeTariffStruct **pptHead)
{
	int iCnt=0;
	static struct MonthFeeTariffStruct *pTemp,*ptHead=NULL;
	struct MonthFeeTariffStruct Temp;
	struct MonthFeeTariffStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyMonthFeeTariff(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct MonthFeeTariffStructIn));
	sprintf(TempIn.sTableName,"MONTH_FEE_TARIFF");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetMonthFeeTariffToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct MonthFeeTariffStruct*)
			malloc(sizeof(struct MonthFeeTariffStruct)))==NULL){

			DestroyMonthFeeTariff(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct MonthFeeTariffStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表MONTH_FEE_TARIFF记录数%d",iCnt);
	}

	WriteProcMsg("加载表MONTH_FEE_TARIFF完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从PROMISE_EXPR_STATE_REASON中用结构缓冲方式取数据*/
int EGetPromiseExprStateReasonToStruct(struct PromiseExprStateReasonStruct *p,
	struct PromiseExprStateReasonStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				EXPR_ID,\n\
				STATE_SEQ,\n\
				nvl(STATE_SEQ_REASON,' '),\n\
				nvl(NAME,' ')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE PROMISE_EXPR_STATE_REASONSCR FROM :statement;
		CheckSqlError(" PREPARE PROMISE_EXPR_STATE_REASONSCR PROMISE_EXPR_STATE_REASONCR");

		EXEC SQL DECLARE PROMISE_EXPR_STATE_REASONCR CURSOR FOR PROMISE_EXPR_STATE_REASONSCR;
		CheckSqlError("Declare PROMISE_EXPR_STATE_REASONCR");

		EXEC SQL OPEN PROMISE_EXPR_STATE_REASONCR;
		CheckSqlError("Open PROMISE_EXPR_STATE_REASONCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE PROMISE_EXPR_STATE_REASONCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH PROMISE_EXPR_STATE_REASONCR INTO
			:pSource->aiExprID,
			:pSource->aiStateSeq,
			:pSource->asStateSeqReason,
			:pSource->asName;
		CheckSqlError("Fetch PROMISE_EXPR_STATE_REASONCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE PROMISE_EXPR_STATE_REASONCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=PROMISE_EXPR_STATE_REASON_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iExprID=			pSource->aiExprID[iCurPos];
		p->iStateSeq=			pSource->aiStateSeq[iCurPos];

		strcpy(p->sStateSeqReason,	pSource->asStateSeqReason[iCurPos]);
		strcpy(p->sName,		pSource->asName[iCurPos]);

		TrimAll(p->sStateSeqReason);
		AllTrim(p->sName);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表PROMISE_EXPR_STATE_REASON的链表释放函数**/
void DestroyPromiseExprStateReason(struct PromiseExprStateReasonStruct *ptHead)
{
	struct PromiseExprStateReasonStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitPromiseExprStateReason(struct PromiseExprStateReasonStruct **pptHead)
{
	int iCnt=0;
	static struct PromiseExprStateReasonStruct *pTemp,*ptHead=NULL;
	struct PromiseExprStateReasonStruct Temp;
	struct PromiseExprStateReasonStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyPromiseExprStateReason(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct PromiseExprStateReasonStructIn));
	sprintf(TempIn.sTableName,"PROMISE_EXPR_STATE_REASON");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetPromiseExprStateReasonToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct PromiseExprStateReasonStruct*)
			malloc(sizeof(struct PromiseExprStateReasonStruct)))==NULL){

			DestroyPromiseExprStateReason(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct PromiseExprStateReasonStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表PROMISE_EXPR_STATE_REASON记录数%d",iCnt);
	}

	WriteProcMsg("加载表PROMISE_EXPR_STATE_REASON完毕总记录数%d",iCnt);

	return iCnt;
}
/*批量数据动态从TEMPLATE_AUDIT_NUM_RES中用结构缓冲方式取数据*/
int EGetAuditNumResToStruct(struct AuditNumResStruct *p,
	struct AuditNumResStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(AREA_CODE,' '),\n\
				nvl(ACC_NBR,' '),\n\
				nvl(RECORD_TYPE,' '),\n\
				to_char(nvl(AUDIT_DATE,SYSDATE+3000),'yyyymmddhh24miss'),\n\
				nvl(AUDIT_STATE,' '),\n\
				nvl(AUDIT_RULE_STR,' '),\n\
				nvl(AUDIT_INFO,' '),\n\
				nvl(AUDIT_ALL_TYPE_STR,' '),\n\
				nvl(AUDIT_DIFF_TYPE_STR,' ')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE TEMPLATE_AUDIT_NUM_RESSCR FROM :statement;
		CheckSqlError(" PREPARE TEMPLATE_AUDIT_NUM_RESSCR TEMPLATE_AUDIT_NUM_RESCR");

		EXEC SQL DECLARE TEMPLATE_AUDIT_NUM_RESCR CURSOR FOR TEMPLATE_AUDIT_NUM_RESSCR;
		CheckSqlError("Declare TEMPLATE_AUDIT_NUM_RESCR");

		EXEC SQL OPEN TEMPLATE_AUDIT_NUM_RESCR;
		CheckSqlError("Open TEMPLATE_AUDIT_NUM_RESCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE TEMPLATE_AUDIT_NUM_RESCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH TEMPLATE_AUDIT_NUM_RESCR INTO
			:pSource->asAreaCode,
			:pSource->asAccNbr,
			:pSource->asRecordType,
			:pSource->asAuditDate,
			:pSource->asAuditState,
			:pSource->asAuditRuleStr,
			:pSource->asAuditInfo,
			:pSource->asAuditAllTypeStr,
			:pSource->asAuditDiffTypeStr;
		CheckSqlError("Fetch TEMPLATE_AUDIT_NUM_RESCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE TEMPLATE_AUDIT_NUM_RESCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=TEMPLATE_AUDIT_NUM_RES_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sAreaCode,		pSource->asAreaCode[iCurPos]);
		strcpy(p->sAccNbr,		pSource->asAccNbr[iCurPos]);
		strcpy(p->sRecordType,		pSource->asRecordType[iCurPos]);
		strcpy(p->sAuditDate,		pSource->asAuditDate[iCurPos]);
		strcpy(p->sAuditState,		pSource->asAuditState[iCurPos]);
		strcpy(p->sAuditRuleStr,	pSource->asAuditRuleStr[iCurPos]);
		strcpy(p->sAuditInfo,		pSource->asAuditInfo[iCurPos]);
		strcpy(p->sAuditAllTypeStr,	pSource->asAuditAllTypeStr[iCurPos]);
		strcpy(p->sAuditDiffTypeStr,	pSource->asAuditDiffTypeStr[iCurPos]);
		
		AllTrim(p->sAreaCode);
		AllTrim(p->sAccNbr);
		AllTrim(p->sRecordType);
		AllTrim(p->sAuditDate);
		AllTrim(p->sAuditState);
		AllTrim(p->sAuditRuleStr);
		AllTrim(p->sAuditInfo);
		AllTrim(p->sAuditAllTypeStr);
		AllTrim(p->sAuditDiffTypeStr);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;

}
/**对表TEMPLATE_AUDIT_NUM_RES的链表释放函数**/
void DestroyAuditNumRes(struct AuditNumResStruct *ptHead)
{
	struct AuditNumResStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitAuditNumRes(struct AuditNumResStruct **pptHead)
{
	int iCnt=0;
	static struct AuditNumResStruct *pTemp,*ptHead=NULL;
	struct AuditNumResStruct Temp;
	struct AuditNumResStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyAuditNumRes(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct AuditNumResStructIn));
	sprintf(TempIn.sTableName,"TEMPLATE_AUDIT_NUM_RES");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetAuditNumResToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct AuditNumResStruct*)
			malloc(sizeof(struct AuditNumResStruct)))==NULL){

			DestroyAuditNumRes(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct AuditNumResStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表TEMPLATE_AUDIT_NUM_RES记录数%d",iCnt);
	}

	WriteProcMsg("加载表AUDIT_NUM_RES完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据结构缓冲写入TEMPLATE_AUDIT_NUM_RES*/
int EInsertStructToAuditNumRes(struct AuditNumResStruct *p,
	int iInsertFlag,struct AuditNumResStructOut *pTarget)
{

	int  iCurPos=pTarget->iCurPos;
	char *sTableName=pTarget->sTableName;

	if(iInsertFlag!=TRUE){

/*放置数据到静态缓冲*/
		strcpy(pTarget->asAreaCode[iCurPos],		p->sAreaCode);
		strcpy(pTarget->asAccNbr[iCurPos],		p->sAccNbr);
		strcpy(pTarget->asRecordType[iCurPos],		p->sRecordType);
		strcpy(pTarget->asAuditDate[iCurPos],		p->sAuditDate);
		strcpy(pTarget->asAuditState[iCurPos],		p->sAuditState);
		strcpy(pTarget->asAuditRuleStr[iCurPos],	p->sAuditRuleStr);
		strcpy(pTarget->asAuditInfo[iCurPos],		p->sAuditInfo);
		strcpy(pTarget->asAuditAllTypeStr[iCurPos],	p->sAuditAllTypeStr);
		strcpy(pTarget->asAuditDiffTypeStr[iCurPos],	p->sAuditDiffTypeStr);

		iCurPos++;
	}

	if(iInsertFlag==TRUE||iCurPos==TEMPLATE_AUDIT_NUM_RES_BUFLEN_OUT){

/* INSERT */
		char statement[8192];

		if(iCurPos==0) return 0;

		sprintf(statement,"\n\
			INSERT INTO %s(\n\
				AREA_CODE,\n\
				ACC_NBR,\n\
				RECORD_TYPE,\n\
				AUDIT_DATE,\n\
				AUDIT_STATE,\n\
				AUDIT_RULE_STR,\n\
				AUDIT_INFO,\n\
				AUDIT_ALL_TYPE_STR,\n\
				AUDIT_DIFF_TYPE_STR)\n\
			VALUES (\n\
				:asAreaCode,\n\
				:asAccNbr,\n\
				:asRecordType,\n\
				to_date(:asAuditDate,'yyyymmddhh24miss'),\n\
				:asAuditState,\n\
				:asAuditRuleStr,\n\
				:asAuditInfo,\n\
				:asAuditAllTypeStr,\n\
				:asAuditDiffTypeStr\n\
			)",sTableName);

		EXEC SQL PREPARE TEMPLATE_AUDIT_NUM_RESTRG FROM :statement;
		if(CheckSqlResult("Prepare insert statement TEMPLATE_AUDIT_NUM_RES")<0) return -1;

		EXEC SQL FOR :iCurPos EXECUTE TEMPLATE_AUDIT_NUM_RESTRG USING
				:pTarget->asAreaCode,
				:pTarget->asAccNbr,
				:pTarget->asRecordType,
				:pTarget->asAuditDate,
				:pTarget->asAuditState,
				:pTarget->asAuditRuleStr,
				:pTarget->asAuditInfo,
				:pTarget->asAuditAllTypeStr,
				:pTarget->asAuditDiffTypeStr;
		if(CheckSqlResult("Dyn insert into TEMPLATE_AUDIT_NUM_RES")<0) return -1;

		iCurPos=0;
	}

	pTarget->iCurPos=iCurPos;
	return 0;

}

/*批量数据动态从PROMISE_TARIFF_COMMENTS中用结构缓冲方式取数据*/
int EGetPromiseTariffCommentsToStruct(struct PromiseTariffCommentsStruct *p,
	struct PromiseTariffCommentsStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(BILLING_TYPE_ID,' '),\n\
				nvl(PROMISE_ELEMENT_ID,0),\n\
				nvl(TARIFF_ID_STR,' '),\n\
				nvl(COMMENTS,' '),\n\
				nvl(STATE,' '),\n\
				to_char(nvl(CREATED_DATE,SYSDATE+3000),'yyyymmddhh24miss'),\n\
				to_char(nvl(STATE_DATE,SYSDATE+3000),'yyyymmddhh24miss')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE PROMISE_TARIFF_COMMENTSSCR FROM :statement;
		CheckSqlError(" PREPARE PROMISE_TARIFF_COMMENTSSCR PROMISE_TARIFF_COMMENTSCR");

		EXEC SQL DECLARE PROMISE_TARIFF_COMMENTSCR CURSOR FOR PROMISE_TARIFF_COMMENTSSCR;
		CheckSqlError("Declare PROMISE_TARIFF_COMMENTSCR");

		EXEC SQL OPEN PROMISE_TARIFF_COMMENTSCR;
		CheckSqlError("Open PROMISE_TARIFF_COMMENTSCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE PROMISE_TARIFF_COMMENTSCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH PROMISE_TARIFF_COMMENTSCR INTO
			:pSource->asBillingTypeID,
			:pSource->aiPromiseElementID,
			:pSource->asTariffIDStr,
			:pSource->asComments,
			:pSource->asState,
			:pSource->asCreatedDate,
			:pSource->asStateDate;
		CheckSqlError("Fetch PROMISE_TARIFF_COMMENTSCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE PROMISE_TARIFF_COMMENTSCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=PROMISE_TARIFF_COMMENTS_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);

		p->iPromiseElementID=		pSource->aiPromiseElementID[iCurPos];

		strcpy(p->sTariffIDStr,		pSource->asTariffIDStr[iCurPos]);
		strcpy(p->sComments,		pSource->asComments[iCurPos]);
		strcpy(p->sState,		pSource->asState[iCurPos]);
		strcpy(p->sCreatedDate,		pSource->asCreatedDate[iCurPos]);
		strcpy(p->sStateDate,		pSource->asStateDate[iCurPos]);

		AllTrim(p->sBillingTypeID);
		AllTrim(p->sTariffIDStr);
		AllTrim(p->sComments);
		AllTrim(p->sState);
		AllTrim(p->sCreatedDate);
		AllTrim(p->sStateDate);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表PROMISE_TARIFF_COMMENTS的链表释放函数**/
void DestroyPromiseTariffComments(struct PromiseTariffCommentsStruct *ptHead)
{
	struct PromiseTariffCommentsStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
/*批量数据结构缓冲写入PROMISE_TARIFF_COMMENTS*/
int EInsertStructToPromiseTariffComments(struct PromiseTariffCommentsStruct *p,
	int iInsertFlag,struct PromiseTariffCommentsStructOut *pTarget)
{

	int  iCurPos=pTarget->iCurPos;
	char *sTableName=pTarget->sTableName;

	if(iInsertFlag!=TRUE){

/*放置数据到静态缓冲*/
		strcpy(pTarget->asBillingTypeID[iCurPos],	p->sBillingTypeID);

		pTarget->aiPromiseElementID[iCurPos]=		p->iPromiseElementID;

		strcpy(pTarget->asTariffIDStr[iCurPos],		p->sTariffIDStr);
		strcpy(pTarget->asComments[iCurPos],		p->sComments);
		strcpy(pTarget->asState[iCurPos],		p->sState);
		strcpy(pTarget->asCreatedDate[iCurPos],		p->sCreatedDate);
		strcpy(pTarget->asStateDate[iCurPos],		p->sStateDate);

		iCurPos++;
	}

	if(iInsertFlag==TRUE||iCurPos==PROMISE_TARIFF_COMMENTS_BUFLEN_OUT){

/* INSERT */
		char statement[8192];

		if(iCurPos==0) return 0;

		sprintf(statement,"\n\
			INSERT INTO %s(\n\
				BILLING_TYPE_ID,\n\
				PROMISE_ELEMENT_ID,\n\
				TARIFF_ID_STR,\n\
				COMMENTS,\n\
				STATE,\n\
				CREATED_DATE,\n\
				STATE_DATE)\n\
			VALUES (\n\
				:asBillingTypeID,\n\
				:aiPromiseElementID,\n\
				:asTariffIDStr,\n\
				:asComments,\n\
				:asState,\n\
				to_date(:asCreatedDate,'yyyymmddhh24miss'),\n\
				to_date(:asStateDate,'yyyymmddhh24miss')\n\
			)",sTableName);

		EXEC SQL PREPARE PROMISE_TARIFF_COMMENTSTRG FROM :statement;
		if(CheckSqlResult("Prepare insert statement PROMISE_TARIFF_COMMENTS")<0) return -1;

		EXEC SQL FOR :iCurPos EXECUTE PROMISE_TARIFF_COMMENTSTRG USING
				:pTarget->asBillingTypeID,
				:pTarget->aiPromiseElementID,
				:pTarget->asTariffIDStr,
				:pTarget->asComments,
				:pTarget->asState,
				:pTarget->asCreatedDate,
				:pTarget->asStateDate;
		if(CheckSqlResult("Dyn insert into PROMISE_TARIFF_COMMENTS")<0) return -1;

		iCurPos=0;
	}

	pTarget->iCurPos=iCurPos;
	return 0;
}

/*批量数据动态从ACCT_ITEM_TYPE_RELATION中用结构缓冲方式取数据*/
int EGetAcctItemTypeRelationToStruct(struct AcctItemTypeRelationStruct *p,
	struct AcctItemTypeRelationStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				ACCT_ITEM_TYPE_ID,\n\
				SUBJECT_ID,\n\
				nvl(ORI_ACCT_ITEM_TYPE_ID,0),\n\
				nvl(CATG,' ')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE ACCT_ITEM_TYPE_RELATIONSCR FROM :statement;
		CheckSqlError(" PREPARE ACCT_ITEM_TYPE_RELATIONSCR ACCT_ITEM_TYPE_RELATIONCR");

		EXEC SQL DECLARE ACCT_ITEM_TYPE_RELATIONCR CURSOR FOR ACCT_ITEM_TYPE_RELATIONSCR;
		CheckSqlError("Declare ACCT_ITEM_TYPE_RELATIONCR");

		EXEC SQL OPEN ACCT_ITEM_TYPE_RELATIONCR;
		CheckSqlError("Open ACCT_ITEM_TYPE_RELATIONCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE ACCT_ITEM_TYPE_RELATIONCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH ACCT_ITEM_TYPE_RELATIONCR INTO
			:pSource->aiAcctItemTypeID,
			:pSource->aiSubjectID,
			:pSource->aiOriAcctItemTypeID,
			:pSource->asCatg;
		CheckSqlError("Fetch ACCT_ITEM_TYPE_RELATIONCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE ACCT_ITEM_TYPE_RELATIONCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=ACCT_ITEM_TYPE_RELATION_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iAcctItemTypeID=	pSource->aiAcctItemTypeID[iCurPos];
		p->iSubjectID=		pSource->aiSubjectID[iCurPos];
		p->iOriAcctItemTypeID=	pSource->aiOriAcctItemTypeID[iCurPos];

		strcpy(p->sCatg,	pSource->asCatg[iCurPos]);

		AllTrim(p->sCatg);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表ACCT_ITEM_TYPE_RELATION的链表释放函数**/
void DestroyAcctItemTypeRelation(struct AcctItemTypeRelationStruct *ptHead)
{
	struct AcctItemTypeRelationStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitAcctItemTypeRelation(struct AcctItemTypeRelationStruct **pptHead)
{
	int iCnt=0;
	static struct AcctItemTypeRelationStruct *pTemp,*ptHead=NULL;
	struct AcctItemTypeRelationStruct Temp;
	struct AcctItemTypeRelationStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyAcctItemTypeRelation(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct AcctItemTypeRelationStructIn));
	sprintf(TempIn.sTableName,"ACCT_ITEM_TYPE_RELATION");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetAcctItemTypeRelationToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct AcctItemTypeRelationStruct*)
			malloc(sizeof(struct AcctItemTypeRelationStruct)))==NULL){

			DestroyAcctItemTypeRelation(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct AcctItemTypeRelationStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表ACCT_ITEM_TYPE_RELATION记录数%d",iCnt);
	}

	WriteProcMsg("加载表ACCT_ITEM_TYPE_RELATION完毕总记录数%d",iCnt);

	return iCnt;
}
/*批量数据动态从ACC_SUBJECT_ITEM中用结构缓冲方式取数据*/
int EGetAccSubjectItemToStruct(struct AccSubjectItemStruct *p,
	struct AccSubjectItemStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(ACC_NBR,' '),\n\
				nvl(SUBSCRIPTION_ID,0),\n\
				nvl(ACCOUNT_ID,0),\n\
				nvl(DEFAULT_ACCOUNT_ID,0),\n\
				nvl(SUBJECT_ID,0),\n\
				to_char(nvl(TOTAL_FEE,0))\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE ACC_SUBJECT_ITEMSCR FROM :statement;
		CheckSqlError(" PREPARE ACC_SUBJECT_ITEMSCR ACC_SUBJECT_ITEMCR");

		EXEC SQL DECLARE ACC_SUBJECT_ITEMCR CURSOR FOR ACC_SUBJECT_ITEMSCR;
		CheckSqlError("Declare ACC_SUBJECT_ITEMCR");

		EXEC SQL OPEN ACC_SUBJECT_ITEMCR;
		CheckSqlError("Open ACC_SUBJECT_ITEMCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE ACC_SUBJECT_ITEMCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH ACC_SUBJECT_ITEMCR INTO
			:pSource->asAccNbr,
			:pSource->aiSubscriptionID,
			:pSource->aiAccountID,
			:pSource->aiDefaultAccountID,
			:pSource->aiSubjectID,
			:pSource->aiTotalFee;
		CheckSqlError("Fetch ACC_SUBJECT_ITEMCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE ACC_SUBJECT_ITEMCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=ACC_SUBJECT_ITEM_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sAccNbr,	pSource->asAccNbr[iCurPos]);

		p->iSubscriptionID=	pSource->aiSubscriptionID[iCurPos];
		p->iAccountID=		pSource->aiAccountID[iCurPos];
		p->iDefaultAccountID=	pSource->aiDefaultAccountID[iCurPos];
		p->iSubjectID=		pSource->aiSubjectID[iCurPos];

		p->iTotalFee=		pSource->aiTotalFee[iCurPos];

		AllTrim(p->sAccNbr);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表ACC_SUBJECT_ITEM的链表释放函数**/
void DestroyAccSubjectItem(struct AccSubjectItemStruct *ptHead)
{
	struct AccSubjectItemStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitAccSubjectItem(struct AccSubjectItemStruct **pptHead)
{
	int iCnt=0;
	static struct AccSubjectItemStruct *pTemp,*ptHead=NULL;
	struct AccSubjectItemStruct Temp;
	struct AccSubjectItemStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyAccSubjectItem(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct AccSubjectItemStructIn));
	sprintf(TempIn.sTableName,"ACC_SUBJECT_ITEM");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetAccSubjectItemToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct AccSubjectItemStruct*)
			malloc(sizeof(struct AccSubjectItemStruct)))==NULL){

			DestroyAccSubjectItem(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct AccSubjectItemStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表ACC_SUBJECT_ITEM记录数%d",iCnt);
	}

	WriteProcMsg("加载表ACC_SUBJECT_ITEM完毕总记录数%d",iCnt);

	return iCnt;
}
/*批量数据动态从ACC_SUBJECT中用结构缓冲方式取数据*/
int EGetAccSubjectToStruct(struct AccSubjectStruct *p,
	struct AccSubjectStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				SUBJECT_ID,\n\
				SUBJECT_NAME,\n\
				nvl(SUBJECT_DESC,' '),\n\
				DISPLAY_UNIT,\n\
				nvl(UNIT_NAME,' '),\n\
				SUBJECT_TYPE,\n\
				SUBJECT_ATTR,\n\
				SUBJECT_MODE,\n\
				OPERATOR_ID,\n\
				OFFICE_ID,\n\
				to_char(CREATE_TIME,'yyyymmddhh24miss')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE ACC_SUBJECTSCR FROM :statement;
		CheckSqlError(" PREPARE ACC_SUBJECTSCR ACC_SUBJECTCR");

		EXEC SQL DECLARE ACC_SUBJECTCR CURSOR FOR ACC_SUBJECTSCR;
		CheckSqlError("Declare ACC_SUBJECTCR");

		EXEC SQL OPEN ACC_SUBJECTCR;
		CheckSqlError("Open ACC_SUBJECTCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE ACC_SUBJECTCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH ACC_SUBJECTCR INTO
			:pSource->aiSubjectID,
			:pSource->asSubjectName,
			:pSource->asSubjectDesc,
			:pSource->aiDisplayUnit,
			:pSource->asUnitName,
			:pSource->aiSubjectType,
			:pSource->aiSubjectAttr,
			:pSource->aiSubjectMode,
			:pSource->asOperatorID,
			:pSource->asOfficeID,
			:pSource->asCreateTime;
		CheckSqlError("Fetch ACC_SUBJECTCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE ACC_SUBJECTCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=ACC_SUBJECT_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iSubjectID=		pSource->aiSubjectID[iCurPos];

		strcpy(p->sSubjectName,	pSource->asSubjectName[iCurPos]);
		strcpy(p->sSubjectDesc,	pSource->asSubjectDesc[iCurPos]);

		p->iDisplayUnit=	pSource->aiDisplayUnit[iCurPos];

		strcpy(p->sUnitName,	pSource->asUnitName[iCurPos]);

		p->iSubjectType=	pSource->aiSubjectType[iCurPos];
		p->iSubjectAttr=	pSource->aiSubjectAttr[iCurPos];
		p->iSubjectMode=	pSource->aiSubjectMode[iCurPos];

		strcpy(p->sOperatorID,	pSource->asOperatorID[iCurPos]);
		strcpy(p->sOfficeID,	pSource->asOfficeID[iCurPos]);
		strcpy(p->sCreateTime,	pSource->asCreateTime[iCurPos]);

		AllTrim(p->sSubjectName);
		AllTrim(p->sSubjectDesc);
		AllTrim(p->sUnitName);
		AllTrim(p->sOperatorID);
		AllTrim(p->sOfficeID);
		AllTrim(p->sCreateTime);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表ACC_SUBJECT的链表释放函数**/
void DestroyAccSubject(struct AccSubjectStruct *ptHead)
{
	struct AccSubjectStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitAccSubject(struct AccSubjectStruct **pptHead)
{
	int iCnt=0;
	static struct AccSubjectStruct *pTemp,*ptHead=NULL;
	struct AccSubjectStruct Temp;
	struct AccSubjectStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyAccSubject(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct AccSubjectStructIn));
	sprintf(TempIn.sTableName,"ACC_SUBJECT");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetAccSubjectToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct AccSubjectStruct*)
			malloc(sizeof(struct AccSubjectStruct)))==NULL){

			DestroyAccSubject(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct AccSubjectStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表ACC_SUBJECT记录数%d",iCnt);
	}

	WriteProcMsg("加载表ACC_SUBJECT完毕总记录数%d",iCnt);

	return iCnt;
}


/*批量数据动态从USER_AUDIT_TASK中用结构缓冲方式取数据*/
int EGetUserAuditTaskToStruct(struct UserAuditTaskStruct *p,
	struct UserAuditTaskStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				TASK_ID,\n\
				TASK_NAME,\n\
				STAFF_ID,\n\
				MONTH,\n\
				AUDIT_TYPE,\n\
				SEQ,\n\
				nvl(TASK_STATE,' '),\n\
				nvl(AREA_CODE,' '),\n\
				nvl(RUN_LOG,' '),\n\
				nvl(TASK_STATE2,' ')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE USER_AUDIT_TASKSCR FROM :statement;
		CheckSqlError(" PREPARE USER_AUDIT_TASKSCR USER_AUDIT_TASKCR");

		EXEC SQL DECLARE USER_AUDIT_TASKCR CURSOR FOR USER_AUDIT_TASKSCR;
		CheckSqlError("Declare USER_AUDIT_TASKCR");

		EXEC SQL OPEN USER_AUDIT_TASKCR;
		CheckSqlError("Open USER_AUDIT_TASKCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE USER_AUDIT_TASKCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH USER_AUDIT_TASKCR INTO
			:pSource->asTaskID,
			:pSource->asTaskName,
			:pSource->aiStaffID,
			:pSource->asMonth,
			:pSource->asAuditType,
			:pSource->aiSeq,
			:pSource->asTaskState,
			:pSource->asAreaCode,
			:pSource->asRunLog,
			:pSource->asTaskState2;
		CheckSqlError("Fetch USER_AUDIT_TASKCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE USER_AUDIT_TASKCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=USER_AUDIT_TASK_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sTaskID,	pSource->asTaskID[iCurPos]);
		strcpy(p->sTaskName,	pSource->asTaskName[iCurPos]);

		p->iStaffID=		pSource->aiStaffID[iCurPos];

		strcpy(p->sMonth,	pSource->asMonth[iCurPos]);
		strcpy(p->sAuditType,	pSource->asAuditType[iCurPos]);

		p->iSeq=		pSource->aiSeq[iCurPos];

		strcpy(p->sTaskState,	pSource->asTaskState[iCurPos]);
		strcpy(p->sAreaCode,	pSource->asAreaCode[iCurPos]);
		strcpy(p->sRunLog,	pSource->asRunLog[iCurPos]);
		strcpy(p->sTaskState2,	pSource->asTaskState2[iCurPos]);

		AllTrim(p->sTaskID);
		AllTrim(p->sTaskName);
		AllTrim(p->sMonth);
		AllTrim(p->sAuditType);
		AllTrim(p->sTaskState);
		AllTrim(p->sAreaCode);
		AllTrim(p->sRunLog);
		AllTrim(p->sTaskState2);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表USER_AUDIT_TASK的链表释放函数**/
void DestroyUserAuditTask(struct UserAuditTaskStruct *ptHead)
{
	struct UserAuditTaskStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}

/*批量数据动态从USER_ATTENTION_BILL中用结构缓冲方式取数据*/
int EGetUserAttentionBillToStruct(struct UserAttentionBillStruct *p,
	struct UserAttentionBillStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				TASK_ID,\n\
				BILLING_TYPE_ID,\n\
				CATG,\n\
				EXTRA_TYPE,\n\
				nvl(EXTRA_COUNT,' '),\n\
				nvl(SHOW_TYPE,' '),\n\
				nvl(AUDIT_STATE,'Y')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE USER_ATTENTION_BILLSCR FROM :statement;
		CheckSqlError(" PREPARE USER_ATTENTION_BILLSCR USER_ATTENTION_BILLCR");

		EXEC SQL DECLARE USER_ATTENTION_BILLCR CURSOR FOR USER_ATTENTION_BILLSCR;
		CheckSqlError("Declare USER_ATTENTION_BILLCR");

		EXEC SQL OPEN USER_ATTENTION_BILLCR;
		CheckSqlError("Open USER_ATTENTION_BILLCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE USER_ATTENTION_BILLCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH USER_ATTENTION_BILLCR INTO
			:pSource->asTaskID,
			:pSource->asBillingTypeID,
			:pSource->asCatg,
			:pSource->asExtraType,
			:pSource->asExtraCount,
			:pSource->asShowType,
			:pSource->asAuditState;
		CheckSqlError("Fetch USER_ATTENTION_BILLCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE USER_ATTENTION_BILLCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=USER_ATTENTION_BILL_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sTaskID,		pSource->asTaskID[iCurPos]);
		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);
		strcpy(p->sCatg,		pSource->asCatg[iCurPos]);
		strcpy(p->sExtraType,		pSource->asExtraType[iCurPos]);
		strcpy(p->sExtraCount,		pSource->asExtraCount[iCurPos]);
		strcpy(p->sShowType,		pSource->asShowType[iCurPos]);
		strcpy(p->sAuditState,		pSource->asAuditState[iCurPos]);

		AllTrim(p->sTaskID);
		AllTrim(p->sBillingTypeID);
		AllTrim(p->sCatg);
		AllTrim(p->sExtraType);
		AllTrim(p->sExtraCount);
		AllTrim(p->sShowType);
		AllTrim(p->sAuditState);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表USER_ATTENTION_BILL的链表释放函数**/
void DestroyUserAttentionBill(struct UserAttentionBillStruct *ptHead)
{
	struct UserAttentionBillStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
/*批量数据动态从USER_ATTENTION_MSISDN中用结构缓冲方式取数据*/
int EGetUserAttentionMsisdnToStruct(struct UserAttentionMsisdnStruct *p,
	struct UserAttentionMsisdnStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				STAFF_ID,\n\
				MSISDN,\n\
				BILLING_TYPE_ID,\n\
				STATE,\n\
				to_char(nvl(CREATE_DATE,SYSDATE+3000),'yyyymmddhh24miss'),\n\
				to_char(nvl(STATE_DATE,SYSDATE+3000),'yyyymmddhh24miss'),\n\
				nvl(CHECK_STATE,' '),\n\
				nvl(TASK_ID,'0')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE USER_ATTENTION_MSISDNSCR FROM :statement;
		CheckSqlError(" PREPARE USER_ATTENTION_MSISDNSCR USER_ATTENTION_MSISDNCR");

		EXEC SQL DECLARE USER_ATTENTION_MSISDNCR CURSOR FOR USER_ATTENTION_MSISDNSCR;
		CheckSqlError("Declare USER_ATTENTION_MSISDNCR");

		EXEC SQL OPEN USER_ATTENTION_MSISDNCR;
		CheckSqlError("Open USER_ATTENTION_MSISDNCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE USER_ATTENTION_MSISDNCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH USER_ATTENTION_MSISDNCR INTO
			:pSource->aiStaffID,
			:pSource->asMsisdn,
			:pSource->asBillingTypeID,
			:pSource->asState,
			:pSource->asCreateDate,
			:pSource->asStateDate,
			:pSource->asCheckState,
			:pSource->asTaskID;
		CheckSqlError("Fetch USER_ATTENTION_MSISDNCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE USER_ATTENTION_MSISDNCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=USER_ATTENTION_MSISDN_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iStaffID=			pSource->aiStaffID[iCurPos];

		strcpy(p->sMsisdn,		pSource->asMsisdn[iCurPos]);
		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);
		strcpy(p->sState,		pSource->asState[iCurPos]);
		strcpy(p->sCreateDate,		pSource->asCreateDate[iCurPos]);
		strcpy(p->sStateDate,		pSource->asStateDate[iCurPos]);
		strcpy(p->sCheckState,		pSource->asCheckState[iCurPos]);
		strcpy(p->sTaskID,		pSource->asTaskID[iCurPos]);

		AllTrim(p->sMsisdn);
		AllTrim(p->sBillingTypeID);
		AllTrim(p->sState);
		AllTrim(p->sCreateDate);
		AllTrim(p->sStateDate);
		AllTrim(p->sCheckState);
		AllTrim(p->sTaskID);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表USER_ATTENTION_MSISDN的链表释放函数**/
void DestroyUserAttentionMsisdn(struct UserAttentionMsisdnStruct *ptHead)
{
	struct UserAttentionMsisdnStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}

/*批量数据动态从AUDIT_TASK_REPORT_DATA中用结构缓冲方式取数据*/
int EGetAuditTaskReportDataToStruct(struct AuditTaskReportDataStruct *p,
	struct AuditTaskReportDataStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(TASK_ID,' '),\n\
				nvl(EXTRA_TYPE,' '),\n\
				nvl(BILLING_TYPE_ID,' '),\n\
				nvl(TYPICAL_MSISDN,' '),\n\
				nvl(ACCT_ID,0),\n\
				nvl(BILLING_RULE,' '),\n\
				nvl(AUDIT_STATE,' '),\n\
				nvl(PROBLEM,' '),\n\
				nvl(ACCT_DETAIL_ID,0),\n\
				nvl(ACCT_DIFF_DETAIL,' '),\n\
				nvl(USER_RULE,' '),\n\
				nvl(PROV_REPLY,' '),\n\
				nvl(CITY_CHECK_RESULT,' '),\n\
				nvl(ATTENTION_TYPE,' '),\n\
				nvl(PROBLEM_BILL,' '),\n\
				nvl(PROBLEM_BILL_ID,' '),\n\
				nvl(ACCT_DIFF_DETAIL2,' ')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE AUDIT_TASK_REPORT_DATASCR FROM :statement;
		CheckSqlError(" PREPARE AUDIT_TASK_REPORT_DATASCR AUDIT_TASK_REPORT_DATACR");

		EXEC SQL DECLARE AUDIT_TASK_REPORT_DATACR CURSOR FOR AUDIT_TASK_REPORT_DATASCR;
		CheckSqlError("Declare AUDIT_TASK_REPORT_DATACR");

		EXEC SQL OPEN AUDIT_TASK_REPORT_DATACR;
		CheckSqlError("Open AUDIT_TASK_REPORT_DATACR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE AUDIT_TASK_REPORT_DATACR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH AUDIT_TASK_REPORT_DATACR INTO
			:pSource->asTaskID,
			:pSource->asExtraType,
			:pSource->asBillingTypeID,
			:pSource->asTypicalMsisdn,
			:pSource->aiAcctID,
			:pSource->asBillingRule,
			:pSource->asAuditState,
			:pSource->asProblem,
			:pSource->aiAcctDetailID,
			:pSource->asAcctDiffDetail,
			:pSource->asUserRule,
			:pSource->asProvReply,
			:pSource->asCityCheckResult,
			:pSource->asAttentionType,
			:pSource->asProblemBill,
			:pSource->asProblemBillID,
			:pSource->asAcctDiffDetail2;
		CheckSqlError("Fetch AUDIT_TASK_REPORT_DATACR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE AUDIT_TASK_REPORT_DATACR;

			return FALSE;
		}

		if(pSource->iRecCnt!=AUDIT_TASK_REPORT_DATA_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sTaskID,		pSource->asTaskID[iCurPos]);
		strcpy(p->sExtraType,		pSource->asExtraType[iCurPos]);
		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);
		strcpy(p->sTypicalMsisdn,	pSource->asTypicalMsisdn[iCurPos]);

		p->iAcctID=			pSource->aiAcctID[iCurPos];

		strcpy(p->sBillingRule,		pSource->asBillingRule[iCurPos]);
		strcpy(p->sAuditState,		pSource->asAuditState[iCurPos]);
		strcpy(p->sProblem,		pSource->asProblem[iCurPos]);

		p->iAcctDetailID=		pSource->aiAcctDetailID[iCurPos];

		strcpy(p->sAcctDiffDetail,	pSource->asAcctDiffDetail[iCurPos]);
		strcpy(p->sUserRule,		pSource->asUserRule[iCurPos]);
		strcpy(p->sProvReply,		pSource->asProvReply[iCurPos]);
		strcpy(p->sCityCheckResult,	pSource->asCityCheckResult[iCurPos]);
		strcpy(p->sAttentionType,	pSource->asAttentionType[iCurPos]);
		strcpy(p->sProblemBill,		pSource->asProblemBill[iCurPos]);
		strcpy(p->sProblemBillID,	pSource->asProblemBillID[iCurPos]);
		strcpy(p->sAcctDiffDetail2,	pSource->asAcctDiffDetail2[iCurPos]);
		
		AllTrim(p->sTaskID);
		AllTrim(p->sExtraType);
		AllTrim(p->sBillingTypeID);
		AllTrim(p->sTypicalMsisdn);
		AllTrim(p->sBillingRule);
		AllTrim(p->sAuditState);
		AllTrim(p->sProblem);
		AllTrim(p->sAcctDiffDetail);
		AllTrim(p->sUserRule);
		AllTrim(p->sProvReply);
		AllTrim(p->sCityCheckResult);
		AllTrim(p->sAttentionType);
		AllTrim(p->sProblemBill);
		AllTrim(p->sProblemBillID);
		AllTrim(p->sAcctDiffDetail2);
		
	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/*批量数据结构缓冲写入AUDIT_TASK_REPORT_DATA*/
int EInsertStructToAuditTaskReportData(struct AuditTaskReportDataStruct *p,
	int iInsertFlag,struct AuditTaskReportDataStructOut *pTarget)
{

	int  iCurPos=pTarget->iCurPos;
	char *sTableName=pTarget->sTableName;

	if(iInsertFlag!=TRUE){

/*放置数据到静态缓冲*/
		strcpy(pTarget->asTaskID[iCurPos],		p->sTaskID);
		strcpy(pTarget->asExtraType[iCurPos],		p->sExtraType);
		strcpy(pTarget->asBillingTypeID[iCurPos],	p->sBillingTypeID);
		strcpy(pTarget->asTypicalMsisdn[iCurPos],	p->sTypicalMsisdn);

		pTarget->aiAcctID[iCurPos]=			p->iAcctID;

		strcpy(pTarget->asBillingRule[iCurPos],		p->sBillingRule);
		strcpy(pTarget->asAuditState[iCurPos],		p->sAuditState);
		strcpy(pTarget->asProblem[iCurPos],		p->sProblem);

		pTarget->aiAcctDetailID[iCurPos]=		p->iAcctDetailID;

		strcpy(pTarget->asAcctDiffDetail[iCurPos],	p->sAcctDiffDetail);
		strcpy(pTarget->asUserRule[iCurPos],		p->sUserRule);
		strcpy(pTarget->asProvReply[iCurPos],		p->sProvReply);
		strcpy(pTarget->asCityCheckResult[iCurPos],	p->sCityCheckResult);
		strcpy(pTarget->asAttentionType[iCurPos],	p->sAttentionType);
		strcpy(pTarget->asProblemBill[iCurPos],		p->sProblemBill);
		strcpy(pTarget->asProblemBillID[iCurPos],	p->sProblemBillID);
		strcpy(pTarget->asAcctDiffDetail2[iCurPos],	p->sAcctDiffDetail2);
		strcpy(pTarget->asDataDate[iCurPos],		p->sDataDate);
		
		iCurPos++;
	}

	if(iInsertFlag==TRUE||iCurPos==AUDIT_TASK_REPORT_DATA_BUFLEN_OUT){

/* INSERT */
		char statement[8192];

		if(iCurPos==0) return 0;

		sprintf(statement,"\n\
			INSERT INTO %s(\n\
				TASK_ID,\n\
				EXTRA_TYPE,\n\
				BILLING_TYPE_ID,\n\
				TYPICAL_MSISDN,\n\
				ACCT_ID,\n\
				BILLING_RULE,\n\
				AUDIT_STATE,\n\
				PROBLEM,\n\
				ACCT_DETAIL_ID,\n\
				ACCT_DIFF_DETAIL,\n\
				USER_RULE,\n\
				PROV_REPLY,\n\
				CITY_CHECK_RESULT,\n\
				ATTENTION_TYPE,\n\
				PROBLEM_BILL,\n\
				PROBLEM_BILL_ID,\n\
				ACCT_DIFF_DETAIL2,\n\
				DATA_DATE)\n\
			VALUES (\n\
				:asTaskID,\n\
				:asExtraType,\n\
				:asBillingTypeID,\n\
				:asTypicalMsisdn,\n\
				:aiAcctID,\n\
				:asBillingRule,\n\
				:asAuditState,\n\
				:asProblem,\n\
				:aiAcctDetailID,\n\
				:asAcctDiffDetail,\n\
				:asUserRule,\n\
				:asProvReply,\n\
				:asCityCheckResult,\n\
				:asAttentionType,\n\
				:asProblemBill,\n\
				:asProblemBillID,\n\
				:asAcctDiffDetail2,\n\
				:asDataDate\n\
			)",sTableName);

		EXEC SQL PREPARE AUDIT_TASK_REPORT_DATATRG FROM :statement;
		if(CheckSqlResult("Prepare insert statement AUDIT_TASK_REPORT_DATA")<0) return -1;

		EXEC SQL FOR :iCurPos EXECUTE AUDIT_TASK_REPORT_DATATRG USING
				:pTarget->asTaskID,
				:pTarget->asExtraType,
				:pTarget->asBillingTypeID,
				:pTarget->asTypicalMsisdn,
				:pTarget->aiAcctID,
				:pTarget->asBillingRule,
				:pTarget->asAuditState,
				:pTarget->asProblem,
				:pTarget->aiAcctDetailID,
				:pTarget->asAcctDiffDetail,
				:pTarget->asUserRule,
				:pTarget->asProvReply,
				:pTarget->asCityCheckResult,
				:pTarget->asAttentionType,
				:pTarget->asProblemBill,
				:pTarget->asProblemBillID,
				:pTarget->asAcctDiffDetail2,
				:pTarget->asDataDate;
		if(CheckSqlResult("Dyn insert into AUDIT_TASK_REPORT_DATA")<0) return -1;

		iCurPos=0;
	}

	pTarget->iCurPos=iCurPos;
	return 0;
}

/**对表AUDIT_TASK_REPORT_DATA的链表释放函数**/
void DestroyAuditTaskReportData(struct AuditTaskReportDataStruct *ptHead)
{
	struct AuditTaskReportDataStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}

/*批量数据动态从AUDIT_ACCT_DETAIL中用结构缓冲方式取数据*/
int EGetAuditAcctDetailToStruct(struct AuditAcctDetailStruct *p,
	struct AuditAcctDetailStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(TASK_ID,' '),\n\
				DETAIL_ID,\n\
				MSISDN,\n\
				nvl(CONTENT,' '),\n\
				nvl(DIFF_FLAG,' ')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE AUDIT_ACCT_DETAILSCR FROM :statement;
		CheckSqlError(" PREPARE AUDIT_ACCT_DETAILSCR AUDIT_ACCT_DETAILCR");

		EXEC SQL DECLARE AUDIT_ACCT_DETAILCR CURSOR FOR AUDIT_ACCT_DETAILSCR;
		CheckSqlError("Declare AUDIT_ACCT_DETAILCR");

		EXEC SQL OPEN AUDIT_ACCT_DETAILCR;
		CheckSqlError("Open AUDIT_ACCT_DETAILCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE AUDIT_ACCT_DETAILCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH AUDIT_ACCT_DETAILCR INTO
			:pSource->asTaskID,
			:pSource->aiDetailID,
			:pSource->asMsisdn,
			:pSource->asContent,
			:pSource->asDiffFlag;
		CheckSqlError("Fetch AUDIT_ACCT_DETAILCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE AUDIT_ACCT_DETAILCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=AUDIT_ACCT_DETAIL_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sTaskID,	pSource->asTaskID[iCurPos]);

		p->iDetailID=		pSource->aiDetailID[iCurPos];

		strcpy(p->sMsisdn,	pSource->asMsisdn[iCurPos]);
		strcpy(p->sContent,	pSource->asContent[iCurPos]);
		strcpy(p->sDiffFlag,	pSource->asDiffFlag[iCurPos]);

		AllTrim(p->sTaskID);
		AllTrim(p->sMsisdn);
		AllTrim(p->sContent);
		AllTrim(p->sDiffFlag);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}

/*批量数据结构缓冲写入AUDIT_ACCT_DETAIL*/
int EInsertStructToAuditAcctDetail(struct AuditAcctDetailStruct *p,
	int iInsertFlag,struct AuditAcctDetailStructOut *pTarget)
{

	int  iCurPos=pTarget->iCurPos;
	char *sTableName=pTarget->sTableName;

	if(iInsertFlag!=TRUE){

/*放置数据到静态缓冲*/
		strcpy(pTarget->asTaskID[iCurPos],	p->sTaskID);

		pTarget->aiDetailID[iCurPos]=		p->iDetailID;

		strcpy(pTarget->asMsisdn[iCurPos],	p->sMsisdn);
		strcpy(pTarget->asContent[iCurPos],	p->sContent);
		strcpy(pTarget->asDiffFlag[iCurPos],	p->sDiffFlag);

		iCurPos++;
	}

	if(iInsertFlag==TRUE||iCurPos==AUDIT_ACCT_DETAIL_BUFLEN_OUT){

/* INSERT */
		char statement[8192];

		if(iCurPos==0) return 0;

		sprintf(statement,"\n\
			INSERT INTO %s(\n\
				TASK_ID,\n\
				DETAIL_ID,\n\
				MSISDN,\n\
				CONTENT,\n\
				DIFF_FLAG)\n\
			VALUES (\n\
				:asTaskID,\n\
				:aiDetailID,\n\
				:asMsisdn,\n\
				:asContent,\n\
				:asDiffFlag\n\
			)",sTableName);

		EXEC SQL PREPARE AUDIT_ACCT_DETAILTRG FROM :statement;
		if(CheckSqlResult("Prepare insert statement AUDIT_ACCT_DETAIL")<0) return -1;

		EXEC SQL FOR :iCurPos EXECUTE AUDIT_ACCT_DETAILTRG USING
				:pTarget->asTaskID,
				:pTarget->aiDetailID,
				:pTarget->asMsisdn,
				:pTarget->asContent,
				:pTarget->asDiffFlag;
		if(CheckSqlResult("Dyn insert into AUDIT_ACCT_DETAIL")<0) return -1;

		iCurPos=0;
	}

	pTarget->iCurPos=iCurPos;
	return 0;
}

/**对表AUDIT_ACCT_DETAIL的链表释放函数**/
void DestroyAuditAcctDetail(struct AuditAcctDetailStruct *ptHead)
{
	struct AuditAcctDetailStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}

/*批量数据动态从MU_OTHER中用结构缓冲方式取数据*/
int EGetMuOtherToStruct(struct MuOtherStruct *p,
	struct MuOtherStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				MU_ID,\n\
				MU_NAME,\n\
				nvl(MU_DESC,' '),\n\
				COMPONENT_ID,\n\
				MEMBER_ID,\n\
				nvl(MEMBER_NAME,' '),\n\
				MEMBER_TYPE,\n\
				to_char(nvl(DATE_ACTIVE,SYSDATE+3000),'yyyymmddhh24miss'),\n\
				to_char(nvl(DATE_INACTIVE,SYSDATE+3000),'yyyymmddhh24miss')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE MU_OTHERSCR FROM :statement;
		CheckSqlError(" PREPARE MU_OTHERSCR MU_OTHERCR");

		EXEC SQL DECLARE MU_OTHERCR CURSOR FOR MU_OTHERSCR;
		CheckSqlError("Declare MU_OTHERCR");

		EXEC SQL OPEN MU_OTHERCR;
		CheckSqlError("Open MU_OTHERCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE MU_OTHERCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH MU_OTHERCR INTO
			:pSource->aiMuID,
			:pSource->asMuName,
			:pSource->asMuDesc,
			:pSource->aiComponentID,
			:pSource->aiMemberID,
			:pSource->asMemberName,
			:pSource->aiMemberType,
			:pSource->asDateActive,
			:pSource->asDateInactive;
		CheckSqlError("Fetch MU_OTHERCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE MU_OTHERCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=MU_OTHER_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iMuID=			pSource->aiMuID[iCurPos];

		strcpy(p->sMuName,		pSource->asMuName[iCurPos]);
		strcpy(p->sMuDesc,		pSource->asMuDesc[iCurPos]);

		p->iComponentID=		pSource->aiComponentID[iCurPos];
		p->iMemberID=			pSource->aiMemberID[iCurPos];

		strcpy(p->sMemberName,		pSource->asMemberName[iCurPos]);

		p->iMemberType=			pSource->aiMemberType[iCurPos];

		strcpy(p->sDateActive,		pSource->asDateActive[iCurPos]);
		strcpy(p->sDateInactive,	pSource->asDateInactive[iCurPos]);

		AllTrim(p->sMuName);
		AllTrim(p->sMuDesc);
		AllTrim(p->sMemberName);
		AllTrim(p->sDateActive);
		AllTrim(p->sDateInactive);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表MU_OTHER的链表释放函数**/
void DestroyMuOther(struct MuOtherStruct *ptHead)
{
	struct MuOtherStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}

/*批量数据动态从USER_AUDIT_LOG中用结构缓冲方式取数据*/
int EGetUserAuditLogToStruct(struct UserAuditLogStruct *p,
	struct UserAuditLogStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(TASK_ID,' '),\n\
				nvl(TYPE,' '),\n\
				nvl(TASK_NAME,' '),\n\
				nvl(STAFF_ID,0),\n\
				nvl(AREA_CODE,' '),\n\
				nvl(MONTH,' '),\n\
				nvl(AUDIT_TYPE,' '),\n\
				nvl(MSISDN_COUNT,0),\n\
				nvl(BILL_COUNT,0),\n\
				nvl(MSISDN_LIST,' '),\n\
				nvl(BILL_LIST,' '),\n\
				nvl(RUN_LOG,' '),\n\
				to_char(nvl(RUN_TIME,SYSDATE+3000),'yyyymmddhh24miss')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE USER_AUDIT_LOGSCR FROM :statement;
		CheckSqlError(" PREPARE USER_AUDIT_LOGSCR USER_AUDIT_LOGCR");

		EXEC SQL DECLARE USER_AUDIT_LOGCR CURSOR FOR USER_AUDIT_LOGSCR;
		CheckSqlError("Declare USER_AUDIT_LOGCR");

		EXEC SQL OPEN USER_AUDIT_LOGCR;
		CheckSqlError("Open USER_AUDIT_LOGCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE USER_AUDIT_LOGCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH USER_AUDIT_LOGCR INTO
			:pSource->asTaskID,
			:pSource->asType,
			:pSource->asTaskName,
			:pSource->aiStaffID,
			:pSource->asAreaCode,
			:pSource->asMonth,
			:pSource->asAuditType,
			:pSource->aiMsisdnCount,
			:pSource->aiBillCount,
			:pSource->asMsisdnList,
			:pSource->asBillList,
			:pSource->asRunLog,
			:pSource->asRunTime;
		CheckSqlError("Fetch USER_AUDIT_LOGCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE USER_AUDIT_LOGCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=USER_AUDIT_LOG_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sTaskID,	pSource->asTaskID[iCurPos]);
		strcpy(p->sType,	pSource->asType[iCurPos]);
		strcpy(p->sTaskName,	pSource->asTaskName[iCurPos]);

		p->iStaffID=		pSource->aiStaffID[iCurPos];

		strcpy(p->sAreaCode,	pSource->asAreaCode[iCurPos]);
		strcpy(p->sMonth,	pSource->asMonth[iCurPos]);
		strcpy(p->sAuditType,	pSource->asAuditType[iCurPos]);

		p->iMsisdnCount=	pSource->aiMsisdnCount[iCurPos];
		p->iBillCount=		pSource->aiBillCount[iCurPos];

		strcpy(p->sMsisdnList,	pSource->asMsisdnList[iCurPos]);
		strcpy(p->sBillList,	pSource->asBillList[iCurPos]);
		strcpy(p->sRunLog,	pSource->asRunLog[iCurPos]);
		strcpy(p->sRunTime,	pSource->asRunTime[iCurPos]);

		AllTrim(p->sTaskID);
		AllTrim(p->sType);
		AllTrim(p->sTaskName);
		AllTrim(p->sAreaCode);
		AllTrim(p->sMonth);
		AllTrim(p->sAuditType);
		AllTrim(p->sMsisdnList);
		AllTrim(p->sBillList);
		AllTrim(p->sRunLog);
		AllTrim(p->sRunTime);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表USER_AUDIT_LOG的链表释放函数**/
void DestroyUserAuditLog(struct UserAuditLogStruct *ptHead)
{
	struct UserAuditLogStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
/*批量数据结构缓冲写入USER_AUDIT_LOG*/
int EInsertStructToUserAuditLog(struct UserAuditLogStruct *p,
	int iInsertFlag,struct UserAuditLogStructOut *pTarget)
{

	int  iCurPos=pTarget->iCurPos;
	char *sTableName=pTarget->sTableName;

	if(iInsertFlag!=TRUE){

/*放置数据到静态缓冲*/
		strcpy(pTarget->asTaskID[iCurPos],	p->sTaskID);
		strcpy(pTarget->asType[iCurPos],	p->sType);
		strcpy(pTarget->asTaskName[iCurPos],	p->sTaskName);

		pTarget->aiStaffID[iCurPos]=		p->iStaffID;

		strcpy(pTarget->asAreaCode[iCurPos],	p->sAreaCode);
		strcpy(pTarget->asMonth[iCurPos],	p->sMonth);
		strcpy(pTarget->asAuditType[iCurPos],	p->sAuditType);

		pTarget->aiMsisdnCount[iCurPos]=	p->iMsisdnCount;
		pTarget->aiBillCount[iCurPos]=		p->iBillCount;

		strcpy(pTarget->asMsisdnList[iCurPos],	p->sMsisdnList);
		strcpy(pTarget->asBillList[iCurPos],	p->sBillList);
		strcpy(pTarget->asRunLog[iCurPos],	p->sRunLog);
		strcpy(pTarget->asRunTime[iCurPos],	p->sRunTime);
		
		pTarget->aiDiffCount[iCurPos]=		p->iDiffCount;
		pTarget->aiAllCount[iCurPos]=		p->iAllCount;
		
		strcpy(pTarget->asAuditState[iCurPos],	p->sAuditState);
		
		iCurPos++;
	}

	if(iInsertFlag==TRUE||iCurPos==USER_AUDIT_LOG_BUFLEN_OUT){

/* INSERT */
		char statement[8192];

		if(iCurPos==0) return 0;

		sprintf(statement,"\n\
			INSERT INTO %s(\n\
				TASK_ID,\n\
				TYPE,\n\
				TASK_NAME,\n\
				STAFF_ID,\n\
				AREA_CODE,\n\
				MONTH,\n\
				AUDIT_TYPE,\n\
				MSISDN_COUNT,\n\
				BILL_COUNT,\n\
				MSISDN_LIST,\n\
				BILL_LIST,\n\
				RUN_LOG,\n\
				RUN_TIME,\n\
				DIFF_COUNT,\n\
				ALL_COUNT,\n\
				AUDIT_STATE)\n\
			VALUES (\n\
				:asTaskID,\n\
				:asType,\n\
				:asTaskName,\n\
				:aiStaffID,\n\
				:asAreaCode,\n\
				:asMonth,\n\
				:asAuditType,\n\
				:aiMsisdnCount,\n\
				:aiBillCount,\n\
				:asMsisdnList,\n\
				:asBillList,\n\
				:asRunLog,\n\
				to_date(:asRunTime,'yyyymmddhh24miss'),\n\
				:aiDiffCount,\n\
				:aiAllCount,\n\
				:asAuditState\n\
			)",sTableName);

		EXEC SQL PREPARE USER_AUDIT_LOGTRG FROM :statement;
		if(CheckSqlResult("Prepare insert statement USER_AUDIT_LOG")<0) return -1;

		EXEC SQL FOR :iCurPos EXECUTE USER_AUDIT_LOGTRG USING
				:pTarget->asTaskID,
				:pTarget->asType,
				:pTarget->asTaskName,
				:pTarget->aiStaffID,
				:pTarget->asAreaCode,
				:pTarget->asMonth,
				:pTarget->asAuditType,
				:pTarget->aiMsisdnCount,
				:pTarget->aiBillCount,
				:pTarget->asMsisdnList,
				:pTarget->asBillList,
				:pTarget->asRunLog,
				:pTarget->asRunTime,
				:pTarget->aiDiffCount,
				:pTarget->aiAllCount,
				:pTarget->asAuditState;
		if(CheckSqlResult("Dyn insert into USER_AUDIT_LOG")<0) return -1;

		iCurPos=0;
	}

	pTarget->iCurPos=iCurPos;
	return 0;
}

/********************************套餐相关性分析部分*************************/

/*批量数据动态从CR_PROMISE_ELEMENT_RELATION中用结构缓冲方式取数据*/
int EGetCrPromiseElementRelationToStruct(struct CrPromiseElementRelationStruct *p,
	struct CrPromiseElementRelationStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(CR_PROMISE_ELEMENT_ID,0),\n\
				nvl(PROMISE_ELEMENT_ID,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_PROMISE_ELEMENT_RELATIONSCR FROM :statement;
		CheckSqlError(" PREPARE CR_PROMISE_ELEMENT_RELATIONSCR CR_PROMISE_ELEMENT_RELATIONCR");

		EXEC SQL DECLARE CR_PROMISE_ELEMENT_RELATIONCR CURSOR FOR CR_PROMISE_ELEMENT_RELATIONSCR;
		CheckSqlError("Declare CR_PROMISE_ELEMENT_RELATIONCR");

		EXEC SQL OPEN CR_PROMISE_ELEMENT_RELATIONCR;
		CheckSqlError("Open CR_PROMISE_ELEMENT_RELATIONCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_PROMISE_ELEMENT_RELATIONCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_PROMISE_ELEMENT_RELATIONCR INTO
			:pSource->aiCrPromiseElementID,
			:pSource->aiPromiseElementID;
		CheckSqlError("Fetch CR_PROMISE_ELEMENT_RELATIONCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_PROMISE_ELEMENT_RELATIONCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_PROMISE_ELEMENT_RELATION_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iCrPromiseElementID=	pSource->aiCrPromiseElementID[iCurPos];
		p->iPromiseElementID=	pSource->aiPromiseElementID[iCurPos];


	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_PROMISE_ELEMENT_RELATION的链表释放函数**/
void DestroyCrPromiseElementRelation(struct CrPromiseElementRelationStruct *ptHead)
{
	struct CrPromiseElementRelationStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrPromiseElementRelation(struct CrPromiseElementRelationStruct **pptHead)
{
	int iCnt=0;
	static struct CrPromiseElementRelationStruct *pTemp,*ptHead=NULL;
	struct CrPromiseElementRelationStruct Temp;
	struct CrPromiseElementRelationStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrPromiseElementRelation(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrPromiseElementRelationStructIn));
	sprintf(TempIn.sTableName,"CR_PROMISE_ELEMENT_RELATION");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrPromiseElementRelationToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrPromiseElementRelationStruct*)
			malloc(sizeof(struct CrPromiseElementRelationStruct)))==NULL){

			DestroyCrPromiseElementRelation(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrPromiseElementRelationStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_PROMISE_ELEMENT_RELATION记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_PROMISE_ELEMENT_RELATION完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从CR_ACCT_ITEM_TYPE_RELATION中用结构缓冲方式取数据*/
int EGetCrAcctItemTypeRelationToStruct(struct CrAcctItemTypeRelationStruct *p,
	struct CrAcctItemTypeRelationStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(CR_ACCT_ITEM_TYPE_ID,0),\n\
				nvl(ACCT_ITEM_TYPE_ID,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_ACCT_ITEM_TYPE_RELATIONSCR FROM :statement;
		CheckSqlError(" PREPARE CR_ACCT_ITEM_TYPE_RELATIONSCR CR_ACCT_ITEM_TYPE_RELATIONCR");

		EXEC SQL DECLARE CR_ACCT_ITEM_TYPE_RELATIONCR CURSOR FOR CR_ACCT_ITEM_TYPE_RELATIONSCR;
		CheckSqlError("Declare CR_ACCT_ITEM_TYPE_RELATIONCR");

		EXEC SQL OPEN CR_ACCT_ITEM_TYPE_RELATIONCR;
		CheckSqlError("Open CR_ACCT_ITEM_TYPE_RELATIONCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_ACCT_ITEM_TYPE_RELATIONCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_ACCT_ITEM_TYPE_RELATIONCR INTO
			:pSource->aiCrAcctItemTypeID,
			:pSource->aiAcctItemTypeID;
		CheckSqlError("Fetch CR_ACCT_ITEM_TYPE_RELATIONCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_ACCT_ITEM_TYPE_RELATIONCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_ACCT_ITEM_TYPE_RELATION_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iCrAcctItemTypeID=	pSource->aiCrAcctItemTypeID[iCurPos];
		p->iAcctItemTypeID=	pSource->aiAcctItemTypeID[iCurPos];


	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_ACCT_ITEM_TYPE_RELATION的链表释放函数**/
void DestroyCrAcctItemTypeRelation(struct CrAcctItemTypeRelationStruct *ptHead)
{
	struct CrAcctItemTypeRelationStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrAcctItemTypeRelation(struct CrAcctItemTypeRelationStruct **pptHead)
{
	int iCnt=0;
	static struct CrAcctItemTypeRelationStruct *pTemp,*ptHead=NULL;
	struct CrAcctItemTypeRelationStruct Temp;
	struct CrAcctItemTypeRelationStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrAcctItemTypeRelation(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrAcctItemTypeRelationStructIn));
	sprintf(TempIn.sTableName,"CR_ACCT_ITEM_TYPE_RELATION");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrAcctItemTypeRelationToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrAcctItemTypeRelationStruct*)
			malloc(sizeof(struct CrAcctItemTypeRelationStruct)))==NULL){

			DestroyCrAcctItemTypeRelation(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrAcctItemTypeRelationStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_ACCT_ITEM_TYPE_RELATION记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_ACCT_ITEM_TYPE_RELATION完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从CR_PATTERN_TARIFF_RELATION中用结构缓冲方式取数据*/
int EGetCrPatternTariffRelationToStruct(struct CrPatternTariffRelationStruct *p,
	struct CrPatternTariffRelationStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(PATTERN_ID,0),\n\
				nvl(TARIFF_ID,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_PATTERN_TARIFF_RELATIONSCR FROM :statement;
		CheckSqlError(" PREPARE CR_PATTERN_TARIFF_RELATIONSCR CR_PATTERN_TARIFF_RELATIONCR");

		EXEC SQL DECLARE CR_PATTERN_TARIFF_RELATIONCR CURSOR FOR CR_PATTERN_TARIFF_RELATIONSCR;
		CheckSqlError("Declare CR_PATTERN_TARIFF_RELATIONCR");

		EXEC SQL OPEN CR_PATTERN_TARIFF_RELATIONCR;
		CheckSqlError("Open CR_PATTERN_TARIFF_RELATIONCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_PATTERN_TARIFF_RELATIONCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_PATTERN_TARIFF_RELATIONCR INTO
			:pSource->aiPatternID,
			:pSource->aiTariffID;
		CheckSqlError("Fetch CR_PATTERN_TARIFF_RELATIONCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_PATTERN_TARIFF_RELATIONCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_PATTERN_TARIFF_RELATION_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iPatternID=	pSource->aiPatternID[iCurPos];
		p->iTariffID=	pSource->aiTariffID[iCurPos];


	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_PATTERN_TARIFF_RELATION的链表释放函数**/
void DestroyCrPatternTariffRelation(struct CrPatternTariffRelationStruct *ptHead)
{
	struct CrPatternTariffRelationStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrPatternTariffRelation(struct CrPatternTariffRelationStruct **pptHead)
{
	int iCnt=0;
	static struct CrPatternTariffRelationStruct *pTemp,*ptHead=NULL;
	struct CrPatternTariffRelationStruct Temp;
	struct CrPatternTariffRelationStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrPatternTariffRelation(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrPatternTariffRelationStructIn));
	sprintf(TempIn.sTableName,"CR_PATTERN_TARIFF_RELATION");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrPatternTariffRelationToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrPatternTariffRelationStruct*)
			malloc(sizeof(struct CrPatternTariffRelationStruct)))==NULL){

			DestroyCrPatternTariffRelation(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrPatternTariffRelationStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_PATTERN_TARIFF_RELATION记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_PATTERN_TARIFF_RELATION完毕总记录数%d",iCnt);

	return iCnt;
}
/*批量数据动态从CR_PROMISE_ELEMENT中用结构缓冲方式取数据*/
int EGetCrPromiseElementToStruct(struct CrPromiseElementStruct *p,
	struct CrPromiseElementStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				PROMISE_ELEMENT_ID,\n\
				nvl(PARENT_ID,0),\n\
				NAME,\n\
				nvl(LEAVE_FLAG,' '),\n\
				nvl(LAY,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_PROMISE_ELEMENTSCR FROM :statement;
		CheckSqlError(" PREPARE CR_PROMISE_ELEMENTSCR CR_PROMISE_ELEMENTCR");

		EXEC SQL DECLARE CR_PROMISE_ELEMENTCR CURSOR FOR CR_PROMISE_ELEMENTSCR;
		CheckSqlError("Declare CR_PROMISE_ELEMENTCR");

		EXEC SQL OPEN CR_PROMISE_ELEMENTCR;
		CheckSqlError("Open CR_PROMISE_ELEMENTCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_PROMISE_ELEMENTCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_PROMISE_ELEMENTCR INTO
			:pSource->aiPromiseElementID,
			:pSource->aiParentID,
			:pSource->asName,
			:pSource->asLeaveFlag,
			:pSource->aiLay;
		CheckSqlError("Fetch CR_PROMISE_ELEMENTCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_PROMISE_ELEMENTCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_PROMISE_ELEMENT_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iPromiseElementID=	pSource->aiPromiseElementID[iCurPos];
		p->iParentID=		pSource->aiParentID[iCurPos];

		strcpy(p->sName,	pSource->asName[iCurPos]);
		strcpy(p->sLeaveFlag,	pSource->asLeaveFlag[iCurPos]);

		p->iLay=		pSource->aiLay[iCurPos];

		AllTrim(p->sName);
		AllTrim(p->sLeaveFlag);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_PROMISE_ELEMENT的链表释放函数**/
void DestroyCrPromiseElement(struct CrPromiseElementStruct *ptHead)
{
	struct CrPromiseElementStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrPromiseElement(struct CrPromiseElementStruct **pptHead)
{
	int iCnt=0;
	static struct CrPromiseElementStruct *pTemp,*ptHead=NULL;
	struct CrPromiseElementStruct Temp;
	struct CrPromiseElementStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrPromiseElement(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrPromiseElementStructIn));
	sprintf(TempIn.sTableName,"CR_PROMISE_ELEMENT");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrPromiseElementToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrPromiseElementStruct*)
			malloc(sizeof(struct CrPromiseElementStruct)))==NULL){

			DestroyCrPromiseElement(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrPromiseElementStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_PROMISE_ELEMENT记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_PROMISE_ELEMENT完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从CR_SERVICE_TYPE中用结构缓冲方式取数据*/
int EGetCrServiceTypeToStruct(struct CrServiceTypeStruct *p,
	struct CrServiceTypeStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				SERVICE_TYPE_ID,\n\
				nvl(PARENT_ID,0),\n\
				NAME,\n\
				nvl(LEAVE_FLAG,' '),\n\
				nvl(LAY,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_SERVICE_TYPESCR FROM :statement;
		CheckSqlError(" PREPARE CR_SERVICE_TYPESCR CR_SERVICE_TYPECR");

		EXEC SQL DECLARE CR_SERVICE_TYPECR CURSOR FOR CR_SERVICE_TYPESCR;
		CheckSqlError("Declare CR_SERVICE_TYPECR");

		EXEC SQL OPEN CR_SERVICE_TYPECR;
		CheckSqlError("Open CR_SERVICE_TYPECR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_SERVICE_TYPECR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_SERVICE_TYPECR INTO
			:pSource->aiServiceTypeID,
			:pSource->aiParentID,
			:pSource->asName,
			:pSource->asLeaveFlag,
			:pSource->aiLay;
		CheckSqlError("Fetch CR_SERVICE_TYPECR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_SERVICE_TYPECR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_SERVICE_TYPE_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iServiceTypeID=	pSource->aiServiceTypeID[iCurPos];
		p->iParentID=		pSource->aiParentID[iCurPos];

		strcpy(p->sName,	pSource->asName[iCurPos]);
		strcpy(p->sLeaveFlag,	pSource->asLeaveFlag[iCurPos]);

		p->iLay=		pSource->aiLay[iCurPos];

		AllTrim(p->sName);
		AllTrim(p->sLeaveFlag);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_SERVICE_TYPE的链表释放函数**/
void DestroyCrServiceType(struct CrServiceTypeStruct *ptHead)
{
	struct CrServiceTypeStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrServiceType(struct CrServiceTypeStruct **pptHead)
{
	int iCnt=0;
	static struct CrServiceTypeStruct *pTemp,*ptHead=NULL;
	struct CrServiceTypeStruct Temp;
	struct CrServiceTypeStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrServiceType(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrServiceTypeStructIn));
	sprintf(TempIn.sTableName,"CR_SERVICE_TYPE");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrServiceTypeToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrServiceTypeStruct*)
			malloc(sizeof(struct CrServiceTypeStruct)))==NULL){

			DestroyCrServiceType(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrServiceTypeStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_SERVICE_TYPE记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_SERVICE_TYPE完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从CR_SERVICE_IMPL_PATTERN中用结构缓冲方式取数据*/
int EGetCrServiceImplPatternToStruct(struct CrServiceImplPatternStruct *p,
	struct CrServiceImplPatternStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				PATTERN_ID,\n\
				nvl(PARENT_ID,0),\n\
				NAME,\n\
				nvl(LEAVE_FLAG,' '),\n\
				nvl(LAY,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_SERVICE_IMPL_PATTERNSCR FROM :statement;
		CheckSqlError(" PREPARE CR_SERVICE_IMPL_PATTERNSCR CR_SERVICE_IMPL_PATTERNCR");

		EXEC SQL DECLARE CR_SERVICE_IMPL_PATTERNCR CURSOR FOR CR_SERVICE_IMPL_PATTERNSCR;
		CheckSqlError("Declare CR_SERVICE_IMPL_PATTERNCR");

		EXEC SQL OPEN CR_SERVICE_IMPL_PATTERNCR;
		CheckSqlError("Open CR_SERVICE_IMPL_PATTERNCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_SERVICE_IMPL_PATTERNCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_SERVICE_IMPL_PATTERNCR INTO
			:pSource->aiPatternID,
			:pSource->aiParentID,
			:pSource->asName,
			:pSource->asLeaveFlag,
			:pSource->aiLay;
		CheckSqlError("Fetch CR_SERVICE_IMPL_PATTERNCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_SERVICE_IMPL_PATTERNCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_SERVICE_IMPL_PATTERN_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iPatternID=		pSource->aiPatternID[iCurPos];
		p->iParentID=		pSource->aiParentID[iCurPos];

		strcpy(p->sName,	pSource->asName[iCurPos]);
		strcpy(p->sLeaveFlag,	pSource->asLeaveFlag[iCurPos]);

		p->iLay=		pSource->aiLay[iCurPos];

		AllTrim(p->sName);
		AllTrim(p->sLeaveFlag);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_SERVICE_IMPL_PATTERN的链表释放函数**/
void DestroyCrServiceImplPattern(struct CrServiceImplPatternStruct *ptHead)
{
	struct CrServiceImplPatternStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrServiceImplPattern(struct CrServiceImplPatternStruct **pptHead)
{
	int iCnt=0;
	static struct CrServiceImplPatternStruct *pTemp,*ptHead=NULL;
	struct CrServiceImplPatternStruct Temp;
	struct CrServiceImplPatternStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrServiceImplPattern(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrServiceImplPatternStructIn));
	sprintf(TempIn.sTableName,"CR_SERVICE_IMPL_PATTERN");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrServiceImplPatternToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrServiceImplPatternStruct*)
			malloc(sizeof(struct CrServiceImplPatternStruct)))==NULL){

			DestroyCrServiceImplPattern(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrServiceImplPatternStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_SERVICE_IMPL_PATTERN记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_SERVICE_IMPL_PATTERN完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从CR_BILL_PROMISE_ELE_RLT中用结构缓冲方式取数据*/
int EGetCrBillPromiseEleRltToStruct(struct CrBillPromiseEleRltStruct *p,
	struct CrBillPromiseEleRltStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(BILLING_TYPE_ID,' '),\n\
				nvl(PROMISE_ELEMENT_ID,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_BILL_PROMISE_ELE_RLTSCR FROM :statement;
		CheckSqlError(" PREPARE CR_BILL_PROMISE_ELE_RLTSCR CR_BILL_PROMISE_ELE_RLTCR");

		EXEC SQL DECLARE CR_BILL_PROMISE_ELE_RLTCR CURSOR FOR CR_BILL_PROMISE_ELE_RLTSCR;
		CheckSqlError("Declare CR_BILL_PROMISE_ELE_RLTCR");

		EXEC SQL OPEN CR_BILL_PROMISE_ELE_RLTCR;
		CheckSqlError("Open CR_BILL_PROMISE_ELE_RLTCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_BILL_PROMISE_ELE_RLTCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_BILL_PROMISE_ELE_RLTCR INTO
			:pSource->asBillingTypeID,
			:pSource->aiPromiseElementID;
		CheckSqlError("Fetch CR_BILL_PROMISE_ELE_RLTCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_BILL_PROMISE_ELE_RLTCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_BILL_PROMISE_ELE_RLT_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);

		p->iPromiseElementID=		pSource->aiPromiseElementID[iCurPos];

		AllTrim(p->sBillingTypeID);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_BILL_PROMISE_ELE_RLT的链表释放函数**/
void DestroyCrBillPromiseEleRlt(struct CrBillPromiseEleRltStruct *ptHead)
{
	struct CrBillPromiseEleRltStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrBillPromiseEleRlt(struct CrBillPromiseEleRltStruct **pptHead)
{
	int iCnt=0;
	static struct CrBillPromiseEleRltStruct *pTemp,*ptHead=NULL;
	struct CrBillPromiseEleRltStruct Temp;
	struct CrBillPromiseEleRltStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrBillPromiseEleRlt(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrBillPromiseEleRltStructIn));
	sprintf(TempIn.sTableName,"CR_BILL_PROMISE_RLT");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrBillPromiseEleRltToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrBillPromiseEleRltStruct*)
			malloc(sizeof(struct CrBillPromiseEleRltStruct)))==NULL){

			DestroyCrBillPromiseEleRlt(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrBillPromiseEleRltStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_BILL_PROMISE_RLT记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_BILL_PROMISE_RLT完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据结构缓冲写入CR_BILL_PROMISE_ELE_RLT*/
int EInsertStructToCrBillPromiseEleRlt(struct CrBillPromiseEleRltStruct *p,
	int iInsertFlag,struct CrBillPromiseEleRltStructOut *pTarget)
{

	int  iCurPos=pTarget->iCurPos;
	char *sTableName=pTarget->sTableName;

	if(iInsertFlag!=TRUE){

/*放置数据到静态缓冲*/
		strcpy(pTarget->asBillingTypeID[iCurPos],	p->sBillingTypeID);

		pTarget->aiPromiseElementID[iCurPos]=		p->iPromiseElementID;

		iCurPos++;
	}

	if(iInsertFlag==TRUE||iCurPos==CR_BILL_PROMISE_ELE_RLT_BUFLEN_OUT){

/* INSERT */
		char statement[8192];

		if(iCurPos==0) return 0;

		sprintf(statement,"\n\
			INSERT INTO %s(\n\
				BILLING_TYPE_ID,\n\
				PROMISE_ELEMENT_ID)\n\
			VALUES (\n\
				:asBillingTypeID,\n\
				:aiPromiseElementID\n\
			)",sTableName);

		EXEC SQL PREPARE CR_BILL_PROMISE_ELE_RLTTRG FROM :statement;
		if(CheckSqlResult("Prepare insert statement CR_BILL_PROMISE_ELE_RLT")<0) return -1;

		EXEC SQL FOR :iCurPos EXECUTE CR_BILL_PROMISE_ELE_RLTTRG USING
				:pTarget->asBillingTypeID,
				:pTarget->aiPromiseElementID;
		if(CheckSqlResult("Dyn insert into CR_BILL_PROMISE_ELE_RLT")<0) return -1;

		iCurPos=0;
	}

	pTarget->iCurPos=iCurPos;
	return 0;
}


/*批量数据动态从CR_BILL_ACCT_ITEM_RLT中用结构缓冲方式取数据*/
int EGetCrBillAcctItemRltToStruct(struct CrBillAcctItemRltStruct *p,
	struct CrBillAcctItemRltStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(BILLING_TYPE_ID,' '),\n\
				nvl(ACCT_ITEM_TYPE_ID,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_BILL_ACCT_ITEM_RLTSCR FROM :statement;
		CheckSqlError(" PREPARE CR_BILL_ACCT_ITEM_RLTSCR CR_BILL_ACCT_ITEM_RLTCR");

		EXEC SQL DECLARE CR_BILL_ACCT_ITEM_RLTCR CURSOR FOR CR_BILL_ACCT_ITEM_RLTSCR;
		CheckSqlError("Declare CR_BILL_ACCT_ITEM_RLTCR");

		EXEC SQL OPEN CR_BILL_ACCT_ITEM_RLTCR;
		CheckSqlError("Open CR_BILL_ACCT_ITEM_RLTCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_BILL_ACCT_ITEM_RLTCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_BILL_ACCT_ITEM_RLTCR INTO
			:pSource->asBillingTypeID,
			:pSource->aiAcctItemTypeID;
		CheckSqlError("Fetch CR_BILL_ACCT_ITEM_RLTCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_BILL_ACCT_ITEM_RLTCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_BILL_ACCT_ITEM_RLT_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);

		p->iAcctItemTypeID=		pSource->aiAcctItemTypeID[iCurPos];

		AllTrim(p->sBillingTypeID);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_BILL_ACCT_ITEM_RLT的链表释放函数**/
void DestroyCrBillAcctItemRlt(struct CrBillAcctItemRltStruct *ptHead)
{
	struct CrBillAcctItemRltStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrBillAcctItemRlt(struct CrBillAcctItemRltStruct **pptHead)
{
	int iCnt=0;
	static struct CrBillAcctItemRltStruct *pTemp,*ptHead=NULL;
	struct CrBillAcctItemRltStruct Temp;
	struct CrBillAcctItemRltStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrBillAcctItemRlt(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrBillAcctItemRltStructIn));
	sprintf(TempIn.sTableName,"CR_BILL_ACCT_ITEM_RLT");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrBillAcctItemRltToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrBillAcctItemRltStruct*)
			malloc(sizeof(struct CrBillAcctItemRltStruct)))==NULL){

			DestroyCrBillAcctItemRlt(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrBillAcctItemRltStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_BILL_ACCT_ITEM_RLT记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_BILL_ACCT_ITEM_RLT完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据结构缓冲写入CR_BILL_ACCT_ITEM_RLT*/
int EInsertStructToCrBillAcctItemRlt(struct CrBillAcctItemRltStruct *p,
	int iInsertFlag,struct CrBillAcctItemRltStructOut *pTarget)
{

	int  iCurPos=pTarget->iCurPos;
	char *sTableName=pTarget->sTableName;

	if(iInsertFlag!=TRUE){

/*放置数据到静态缓冲*/
		strcpy(pTarget->asBillingTypeID[iCurPos],	p->sBillingTypeID);

		pTarget->aiAcctItemTypeID[iCurPos]=		p->iAcctItemTypeID;

		iCurPos++;
	}

	if(iInsertFlag==TRUE||iCurPos==CR_BILL_ACCT_ITEM_RLT_BUFLEN_OUT){

/* INSERT */
		char statement[8192];

		if(iCurPos==0) return 0;

		sprintf(statement,"\n\
			INSERT INTO %s(\n\
				BILLING_TYPE_ID,\n\
				ACCT_ITEM_TYPE_ID)\n\
			VALUES (\n\
				:asBillingTypeID,\n\
				:aiAcctItemTypeID\n\
			)",sTableName);

		EXEC SQL PREPARE CR_BILL_ACCT_ITEM_RLTTRG FROM :statement;
		if(CheckSqlResult("Prepare insert statement CR_BILL_ACCT_ITEM_RLT")<0) return -1;

		EXEC SQL FOR :iCurPos EXECUTE CR_BILL_ACCT_ITEM_RLTTRG USING
				:pTarget->asBillingTypeID,
				:pTarget->aiAcctItemTypeID;
		if(CheckSqlResult("Dyn insert into CR_BILL_ACCT_ITEM_RLT")<0) return -1;

		iCurPos=0;
	}

	pTarget->iCurPos=iCurPos;
	return 0;
}


/*批量数据动态从CR_BILL_PATTERN_RLT中用结构缓冲方式取数据*/
int EGetCrBillPatternRltToStruct(struct CrBillPatternRltStruct *p,
	struct CrBillPatternRltStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(BILLING_TYPE_ID,' '),\n\
				nvl(PATTERN_ID,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_BILL_PATTERN_RLTSCR FROM :statement;
		CheckSqlError(" PREPARE CR_BILL_PATTERN_RLTSCR CR_BILL_PATTERN_RLTCR");

		EXEC SQL DECLARE CR_BILL_PATTERN_RLTCR CURSOR FOR CR_BILL_PATTERN_RLTSCR;
		CheckSqlError("Declare CR_BILL_PATTERN_RLTCR");

		EXEC SQL OPEN CR_BILL_PATTERN_RLTCR;
		CheckSqlError("Open CR_BILL_PATTERN_RLTCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_BILL_PATTERN_RLTCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_BILL_PATTERN_RLTCR INTO
			:pSource->asBillingTypeID,
			:pSource->aiPatternID;
		CheckSqlError("Fetch CR_BILL_PATTERN_RLTCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_BILL_PATTERN_RLTCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_BILL_PATTERN_RLT_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);

		p->iPatternID=			pSource->aiPatternID[iCurPos];

		AllTrim(p->sBillingTypeID);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_BILL_PATTERN_RLT的链表释放函数**/
void DestroyCrBillPatternRlt(struct CrBillPatternRltStruct *ptHead)
{
	struct CrBillPatternRltStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrBillPatternRlt(struct CrBillPatternRltStruct **pptHead)
{
	int iCnt=0;
	static struct CrBillPatternRltStruct *pTemp,*ptHead=NULL;
	struct CrBillPatternRltStruct Temp;
	struct CrBillPatternRltStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrBillPatternRlt(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrBillPatternRltStructIn));
	sprintf(TempIn.sTableName,"CR_BILL_PATTERN_RLT");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrBillPatternRltToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrBillPatternRltStruct*)
			malloc(sizeof(struct CrBillPatternRltStruct)))==NULL){

			DestroyCrBillPatternRlt(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrBillPatternRltStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_BILL_PATTERN_RLT记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_BILL_PATTERN_RLT完毕总记录数%d",iCnt);

	return iCnt;
}
/*批量数据结构缓冲写入CR_BILL_PATTERN_RLT*/
int EInsertStructToCrBillPatternRlt(struct CrBillPatternRltStruct *p,
	int iInsertFlag,struct CrBillPatternRltStructOut *pTarget)
{

	int  iCurPos=pTarget->iCurPos;
	char *sTableName=pTarget->sTableName;

	if(iInsertFlag!=TRUE){

/*放置数据到静态缓冲*/
		strcpy(pTarget->asBillingTypeID[iCurPos],	p->sBillingTypeID);

		pTarget->aiPatternID[iCurPos]=			p->iPatternID;

		iCurPos++;
	}

	if(iInsertFlag==TRUE||iCurPos==CR_BILL_PATTERN_RLT_BUFLEN_OUT){

/* INSERT */
		char statement[8192];

		if(iCurPos==0) return 0;

		sprintf(statement,"\n\
			INSERT INTO %s(\n\
				BILLING_TYPE_ID,\n\
				PATTERN_ID)\n\
			VALUES (\n\
				:asBillingTypeID,\n\
				:aiPatternID\n\
			)",sTableName);

		EXEC SQL PREPARE CR_BILL_PATTERN_RLTTRG FROM :statement;
		if(CheckSqlResult("Prepare insert statement CR_BILL_PATTERN_RLT")<0) return -1;

		EXEC SQL FOR :iCurPos EXECUTE CR_BILL_PATTERN_RLTTRG USING
				:pTarget->asBillingTypeID,
				:pTarget->aiPatternID;
		if(CheckSqlResult("Dyn insert into CR_BILL_PATTERN_RLT")<0) return -1;

		iCurPos=0;
	}

	pTarget->iCurPos=iCurPos;
	return 0;
}

/*批量数据动态从CR_BILL_SERV_TYPE_RLT中用结构缓冲方式取数据*/
int EGetCrBillServTypeRltToStruct(struct CrBillServTypeRltStruct *p,
	struct CrBillServTypeRltStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(BILLING_TYPE_ID,' '),\n\
				nvl(SERVICE_TYPE_ID,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_BILL_SERV_TYPE_RLTSCR FROM :statement;
		CheckSqlError(" PREPARE CR_BILL_SERV_TYPE_RLTSCR CR_BILL_SERV_TYPE_RLTCR");

		EXEC SQL DECLARE CR_BILL_SERV_TYPE_RLTCR CURSOR FOR CR_BILL_SERV_TYPE_RLTSCR;
		CheckSqlError("Declare CR_BILL_SERV_TYPE_RLTCR");

		EXEC SQL OPEN CR_BILL_SERV_TYPE_RLTCR;
		CheckSqlError("Open CR_BILL_SERV_TYPE_RLTCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_BILL_SERV_TYPE_RLTCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_BILL_SERV_TYPE_RLTCR INTO
			:pSource->asBillingTypeID,
			:pSource->aiServiceTypeID;
		CheckSqlError("Fetch CR_BILL_SERV_TYPE_RLTCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_BILL_SERV_TYPE_RLTCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_BILL_SERV_TYPE_RLT_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);

		p->iServiceTypeID=		pSource->aiServiceTypeID[iCurPos];

		AllTrim(p->sBillingTypeID);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_BILL_SERV_TYPE_RLT的链表释放函数**/
void DestroyCrBillServTypeRlt(struct CrBillServTypeRltStruct *ptHead)
{
	struct CrBillServTypeRltStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrBillServTypeRlt(struct CrBillServTypeRltStruct **pptHead)
{
	int iCnt=0;
	static struct CrBillServTypeRltStruct *pTemp,*ptHead=NULL;
	struct CrBillServTypeRltStruct Temp;
	struct CrBillServTypeRltStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrBillServTypeRlt(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrBillServTypeRltStructIn));
	sprintf(TempIn.sTableName,"CR_BILL_SERV_TYPE_RLT");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrBillServTypeRltToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrBillServTypeRltStruct*)
			malloc(sizeof(struct CrBillServTypeRltStruct)))==NULL){

			DestroyCrBillServTypeRlt(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrBillServTypeRltStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_BILL_SERV_TYPE_RLT记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_BILL_SERV_TYPE_RLT完毕总记录数%d",iCnt);

	return iCnt;
}
/*批量数据结构缓冲写入CR_BILL_SERV_TYPE_RLT*/
int EInsertStructToCrBillServTypeRlt(struct CrBillServTypeRltStruct *p,
	int iInsertFlag,struct CrBillServTypeRltStructOut *pTarget)
{

	int  iCurPos=pTarget->iCurPos;
	char *sTableName=pTarget->sTableName;

	if(iInsertFlag!=TRUE){

/*放置数据到静态缓冲*/
		strcpy(pTarget->asBillingTypeID[iCurPos],	p->sBillingTypeID);

		pTarget->aiServiceTypeID[iCurPos]=		p->iServiceTypeID;

		iCurPos++;
	}

	if(iInsertFlag==TRUE||iCurPos==CR_BILL_SERV_TYPE_RLT_BUFLEN_OUT){

/* INSERT */
		char statement[8192];

		if(iCurPos==0) return 0;

		sprintf(statement,"\n\
			INSERT INTO %s(\n\
				BILLING_TYPE_ID,\n\
				SERVICE_TYPE_ID)\n\
			VALUES (\n\
				:asBillingTypeID,\n\
				:aiServiceTypeID\n\
			)",sTableName);

		EXEC SQL PREPARE CR_BILL_SERV_TYPE_RLTTRG FROM :statement;
		if(CheckSqlResult("Prepare insert statement CR_BILL_SERV_TYPE_RLT")<0) return -1;

		EXEC SQL FOR :iCurPos EXECUTE CR_BILL_SERV_TYPE_RLTTRG USING
				:pTarget->asBillingTypeID,
				:pTarget->aiServiceTypeID;
		if(CheckSqlResult("Dyn insert into CR_BILL_SERV_TYPE_RLT")<0) return -1;

		iCurPos=0;
	}

	pTarget->iCurPos=iCurPos;
	return 0;
}

/****************第三部分数据***************************

用户套餐(承诺要素)指标关系、用户套餐(账目类型)指标关系
用户套餐(业务类型)指标关系、用户套餐(业务实现模式)指标关系

*******************************************************/
/*批量数据动态从USER_BILL_PROMISE_ELE_RLT中用结构缓冲方式取数据*/
int EGetUserBillPromiseEleRltToStruct(struct CrUserBillPromiseEleRltStruct *p,
	struct CrUserBillPromiseEleRltStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(ACC_NBR,' '),\n\
				nvl(SUBSCRIPTION_ID,0),\n\
				nvl(BILLING_TYPE_ID,' '),\n\
				nvl(PROMISE_ELEMENT_ID,0),\n\
				nvl(RELATION_TYPE,' '),\n\
				nvl(USAGE,0),\n\
				nvl(WEIGHT,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE USER_BILL_PROMISE_ELE_RLTSCR FROM :statement;
		CheckSqlError(" PREPARE USER_BILL_PROMISE_ELE_RLTSCR USER_BILL_PROMISE_ELE_RLTCR");

		EXEC SQL DECLARE USER_BILL_PROMISE_ELE_RLTCR CURSOR FOR USER_BILL_PROMISE_ELE_RLTSCR;
		CheckSqlError("Declare USER_BILL_PROMISE_ELE_RLTCR");

		EXEC SQL OPEN USER_BILL_PROMISE_ELE_RLTCR;
		CheckSqlError("Open USER_BILL_PROMISE_ELE_RLTCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE USER_BILL_PROMISE_ELE_RLTCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH USER_BILL_PROMISE_ELE_RLTCR INTO
			:pSource->asAccNbr,
			:pSource->aiSubscriptionID,
			:pSource->asBillingTypeID,
			:pSource->aiPromiseElementID,
			:pSource->asRelationType,
			:pSource->aiUsage,
			:pSource->aiWeight;
		CheckSqlError("Fetch USER_BILL_PROMISE_ELE_RLTCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE USER_BILL_PROMISE_ELE_RLTCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=USER_BILL_PROMISE_ELE_RLT_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sAccNbr,		pSource->asAccNbr[iCurPos]);
		p->iSubscriptionID=		pSource->aiSubscriptionID[iCurPos];
		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);

		p->iPromiseElementID=		pSource->aiPromiseElementID[iCurPos];

		strcpy(p->sRelationType,	pSource->asRelationType[iCurPos]);

		p->iUsage=			pSource->aiUsage[iCurPos];
		p->iWeight=			pSource->aiWeight[iCurPos];

		AllTrim(p->sAccNbr);
		AllTrim(p->sBillingTypeID);
		AllTrim(p->sRelationType);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表USER_BILL_PROMISE_ELE_RLT的链表释放函数**/
void DestroyUserBillPromiseEleRlt(struct CrUserBillPromiseEleRltStruct *ptHead)
{
	struct CrUserBillPromiseEleRltStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitUserBillPromiseEleRlt(struct CrUserBillPromiseEleRltStruct **pptHead)
{
	int iCnt=0;
	static struct CrUserBillPromiseEleRltStruct *pTemp,*ptHead=NULL;
	struct CrUserBillPromiseEleRltStruct Temp;
	struct CrUserBillPromiseEleRltStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyUserBillPromiseEleRlt(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrUserBillPromiseEleRltStructIn));
	sprintf(TempIn.sTableName,"CR_USER_BILL_PROMISE_RLT");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetUserBillPromiseEleRltToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrUserBillPromiseEleRltStruct*)
			malloc(sizeof(struct CrUserBillPromiseEleRltStruct)))==NULL){

			DestroyUserBillPromiseEleRlt(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrUserBillPromiseEleRltStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_USER_BILL_PROMISE_RLT记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_USER_BILL_PROMISE_RLT完毕总记录数%d",iCnt);

	return iCnt;
}
/*批量数据结构缓冲写入USER_BILL_PROMISE_ELE_RLT*/
int EInsertStructToUserBillPromiseEleRlt(struct CrUserBillPromiseEleRltStruct *p,
	int iInsertFlag,struct CrUserBillPromiseEleRltStructOut *pTarget)
{

	int  iCurPos=pTarget->iCurPos;
	char *sTableName=pTarget->sTableName;

	if(iInsertFlag!=TRUE){

/*放置数据到静态缓冲*/
		strcpy(pTarget->asAccNbr[iCurPos],		p->sAccNbr);
		strcpy(pTarget->asBillingTypeID[iCurPos],	p->sBillingTypeID);

		pTarget->aiPromiseElementID[iCurPos]=		p->iPromiseElementID;

		strcpy(pTarget->asRelationType[iCurPos],	p->sRelationType);

		pTarget->aiUsage[iCurPos]=			p->iUsage;
		pTarget->aiWeight[iCurPos]=			p->iWeight;

		iCurPos++;
	}

	if(iInsertFlag==TRUE||iCurPos==USER_BILL_PROMISE_ELE_RLT_BUFLEN_OUT){

/* INSERT */
		char statement[8192];

		if(iCurPos==0) return 0;

		sprintf(statement,"\n\
			INSERT INTO %s(\n\
				ACC_NBR,\n\
				BILLING_TYPE_ID,\n\
				PROMISE_ELEMENT_ID,\n\
				RELATION_TYPE,\n\
				USAGE,\n\
				WEIGHT)\n\
			VALUES (\n\
				:asAccNbr,\n\
				:asBillingTypeID,\n\
				:aiPromiseElementID,\n\
				:asRelationType,\n\
				:aiUsage,\n\
				:aiWeight\n\
			)",sTableName);

		EXEC SQL PREPARE USER_BILL_PROMISE_ELE_RLTTRG FROM :statement;
		if(CheckSqlResult("Prepare insert statement USER_BILL_PROMISE_ELE_RLT")<0) return -1;

		EXEC SQL FOR :iCurPos EXECUTE USER_BILL_PROMISE_ELE_RLTTRG USING
				:pTarget->asAccNbr,
				:pTarget->asBillingTypeID,
				:pTarget->aiPromiseElementID,
				:pTarget->asRelationType,
				:pTarget->aiUsage,
				:pTarget->aiWeight;
		if(CheckSqlResult("Dyn insert into USER_BILL_PROMISE_ELE_RLT")<0) return -1;

		iCurPos=0;
	}

	pTarget->iCurPos=iCurPos;
	return 0;
}

/*批量数据动态从CR_USER_BILL_ACCT_ITEM_RLT中用结构缓冲方式取数据*/
int EGetCrUserBillAcctItemRltToStruct(struct CrUserBillAcctItemRltStruct *p,
	struct CrUserBillAcctItemRltStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(ACC_NBR,' '),\n\
				nvl(SUBSCRIPTION_ID,0),\n\
				nvl(BILLING_TYPE_ID,' '),\n\
				nvl(ACCT_ITEM_TYPE_ID,0),\n\
				nvl(RELATION_TYPE,' '),\n\
				nvl(USAGE,0),\n\
				nvl(WEIGHT,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_USER_BILL_ACCT_ITEM_RLTSCR FROM :statement;
		CheckSqlError(" PREPARE CR_USER_BILL_ACCT_ITEM_RLTSCR CR_USER_BILL_ACCT_ITEM_RLTCR");

		EXEC SQL DECLARE CR_USER_BILL_ACCT_ITEM_RLTCR CURSOR FOR CR_USER_BILL_ACCT_ITEM_RLTSCR;
		CheckSqlError("Declare CR_USER_BILL_ACCT_ITEM_RLTCR");

		EXEC SQL OPEN CR_USER_BILL_ACCT_ITEM_RLTCR;
		CheckSqlError("Open CR_USER_BILL_ACCT_ITEM_RLTCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_USER_BILL_ACCT_ITEM_RLTCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_USER_BILL_ACCT_ITEM_RLTCR INTO
			:pSource->asAccNbr,
			:pSource->aiSubscriptionID,
			:pSource->asBillingTypeID,
			:pSource->aiAcctItemTypeID,
			:pSource->asRelationType,
			:pSource->aiUsage,
			:pSource->aiWeight;
		CheckSqlError("Fetch CR_USER_BILL_ACCT_ITEM_RLTCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_USER_BILL_ACCT_ITEM_RLTCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_USER_BILL_ACCT_ITEM_RLT_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sAccNbr,		pSource->asAccNbr[iCurPos]);
		p->iSubscriptionID=		pSource->aiSubscriptionID[iCurPos];
		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);

		p->iAcctItemTypeID=		pSource->aiAcctItemTypeID[iCurPos];

		strcpy(p->sRelationType,	pSource->asRelationType[iCurPos]);

		p->iUsage=			pSource->aiUsage[iCurPos];
		p->iWeight=			pSource->aiWeight[iCurPos];

		AllTrim(p->sAccNbr);
		AllTrim(p->sBillingTypeID);
		AllTrim(p->sRelationType);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_USER_BILL_ACCT_ITEM_RLT的链表释放函数**/
void DestroyCrUserBillAcctItemRlt(struct CrUserBillAcctItemRltStruct *ptHead)
{
	struct CrUserBillAcctItemRltStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrUserBillAcctItemRlt(struct CrUserBillAcctItemRltStruct **pptHead)
{
	int iCnt=0;
	static struct CrUserBillAcctItemRltStruct *pTemp,*ptHead=NULL;
	struct CrUserBillAcctItemRltStruct Temp;
	struct CrUserBillAcctItemRltStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrUserBillAcctItemRlt(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrUserBillAcctItemRltStructIn));
	sprintf(TempIn.sTableName,"CR_USER_BILL_ACCT_ITEM_RLT");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrUserBillAcctItemRltToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrUserBillAcctItemRltStruct*)
			malloc(sizeof(struct CrUserBillAcctItemRltStruct)))==NULL){

			DestroyCrUserBillAcctItemRlt(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrUserBillAcctItemRltStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_USER_BILL_ACCT_ITEM_RLT记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_USER_BILL_ACCT_ITEM_RLT完毕总记录数%d",iCnt);

	return iCnt;
}
/*批量数据结构缓冲写入CR_USER_BILL_ACCT_ITEM_RLT*/
int EInsertStructToCrUserBillAcctItemRlt(struct CrUserBillAcctItemRltStruct *p,
	int iInsertFlag,struct CrUserBillAcctItemRltStructOut *pTarget)
{

	int  iCurPos=pTarget->iCurPos;
	char *sTableName=pTarget->sTableName;

	if(iInsertFlag!=TRUE){

/*放置数据到静态缓冲*/
		strcpy(pTarget->asAccNbr[iCurPos],		p->sAccNbr);
		strcpy(pTarget->asBillingTypeID[iCurPos],	p->sBillingTypeID);

		pTarget->aiAcctItemTypeID[iCurPos]=		p->iAcctItemTypeID;

		strcpy(pTarget->asRelationType[iCurPos],	p->sRelationType);

		pTarget->aiUsage[iCurPos]=			p->iUsage;
		pTarget->aiWeight[iCurPos]=			p->iWeight;

		iCurPos++;
	}

	if(iInsertFlag==TRUE||iCurPos==CR_USER_BILL_ACCT_ITEM_RLT_BUFLEN_OUT){

/* INSERT */
		char statement[8192];

		if(iCurPos==0) return 0;

		sprintf(statement,"\n\
			INSERT INTO %s(\n\
				ACC_NBR,\n\
				BILLING_TYPE_ID,\n\
				ACCT_ITEM_TYPE_ID,\n\
				RELATION_TYPE,\n\
				USAGE,\n\
				WEIGHT)\n\
			VALUES (\n\
				:asAccNbr,\n\
				:asBillingTypeID,\n\
				:aiAcctItemTypeID,\n\
				:asRelationType,\n\
				:aiUsage,\n\
				:aiWeight\n\
			)",sTableName);

		EXEC SQL PREPARE CR_USER_BILL_ACCT_ITEM_RLTTRG FROM :statement;
		if(CheckSqlResult("Prepare insert statement CR_USER_BILL_ACCT_ITEM_RLT")<0) return -1;

		EXEC SQL FOR :iCurPos EXECUTE CR_USER_BILL_ACCT_ITEM_RLTTRG USING
				:pTarget->asAccNbr,
				:pTarget->asBillingTypeID,
				:pTarget->aiAcctItemTypeID,
				:pTarget->asRelationType,
				:pTarget->aiUsage,
				:pTarget->aiWeight;
		if(CheckSqlResult("Dyn insert into CR_USER_BILL_ACCT_ITEM_RLT")<0) return -1;

		iCurPos=0;
	}

	pTarget->iCurPos=iCurPos;
	return 0;
}

/*批量数据动态从CR_USER_BILL_SERVICE_TYPE_RLT中用结构缓冲方式取数据*/
int EGetCrUserBillServiceTypeRltToStruct(struct CrUserBillServiceTypeRltStruct *p,
	struct CrUserBillServiceTypeRltStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(ACC_NBR,' '),\n\
				nvl(SUBSCRIPTION_ID,0),\n\
				nvl(BILLING_TYPE_ID,' '),\n\
				nvl(SERVICE_TYPE_ID,0),\n\
				nvl(RELATION_TYPE,' '),\n\
				nvl(USAGE,0),\n\
				nvl(WEIGHT,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_USER_BILL_SERVICE_TYPE_RLTSCR FROM :statement;
		CheckSqlError(" PREPARE CR_USER_BILL_SERVICE_TYPE_RLTSCR CR_USER_BILL_SERVICE_TYPE_RLTCR");

		EXEC SQL DECLARE CR_USER_BILL_SERVICE_TYPE_RLTCR CURSOR FOR CR_USER_BILL_SERVICE_TYPE_RLTSCR;
		CheckSqlError("Declare CR_USER_BILL_SERVICE_TYPE_RLTCR");

		EXEC SQL OPEN CR_USER_BILL_SERVICE_TYPE_RLTCR;
		CheckSqlError("Open CR_USER_BILL_SERVICE_TYPE_RLTCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_USER_BILL_SERVICE_TYPE_RLTCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_USER_BILL_SERVICE_TYPE_RLTCR INTO
			:pSource->asAccNbr,
			:pSource->aiSubscriptionID,
			:pSource->asBillingTypeID,
			:pSource->aiServiceTypeID,
			:pSource->asRelationType,
			:pSource->aiUsage,
			:pSource->aiWeight;
		CheckSqlError("Fetch CR_USER_BILL_SERVICE_TYPE_RLTCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_USER_BILL_SERVICE_TYPE_RLTCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_USER_BILL_SERVICE_TYPE_RLT_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sAccNbr,		pSource->asAccNbr[iCurPos]);
		p->iSubscriptionID=		pSource->aiSubscriptionID[iCurPos];
		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);

		p->iServiceTypeID=		pSource->aiServiceTypeID[iCurPos];

		strcpy(p->sRelationType,	pSource->asRelationType[iCurPos]);

		p->iUsage=			pSource->aiUsage[iCurPos];
		p->iWeight=			pSource->aiWeight[iCurPos];

		AllTrim(p->sAccNbr);
		AllTrim(p->sBillingTypeID);
		AllTrim(p->sRelationType);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_USER_BILL_SERVICE_TYPE_RLT的链表释放函数**/
void DestroyCrUserBillServiceTypeRlt(struct CrUserBillServiceTypeRltStruct *ptHead)
{
	struct CrUserBillServiceTypeRltStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrUserBillServiceTypeRlt(struct CrUserBillServiceTypeRltStruct **pptHead)
{
	int iCnt=0;
	static struct CrUserBillServiceTypeRltStruct *pTemp,*ptHead=NULL;
	struct CrUserBillServiceTypeRltStruct Temp;
	struct CrUserBillServiceTypeRltStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrUserBillServiceTypeRlt(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrUserBillServiceTypeRltStructIn));
	sprintf(TempIn.sTableName,"CR_USER_BILL_SERVICE_TYPE_RLT");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrUserBillServiceTypeRltToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrUserBillServiceTypeRltStruct*)
			malloc(sizeof(struct CrUserBillServiceTypeRltStruct)))==NULL){

			DestroyCrUserBillServiceTypeRlt(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrUserBillServiceTypeRltStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_USER_BILL_SERVICE_TYPE_RLT记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_USER_BILL_SERVICE_TYPE_RLT完毕总记录数%d",iCnt);

	return iCnt;
}
/*批量数据结构缓冲写入CR_USER_BILL_SERVICE_TYPE_RLT*/
int EInsertStructToCrUserBillServiceTypeRlt(struct CrUserBillServiceTypeRltStruct *p,
	int iInsertFlag,struct CrUserBillServiceTypeRltStructOut *pTarget)
{

	int  iCurPos=pTarget->iCurPos;
	char *sTableName=pTarget->sTableName;

	if(iInsertFlag!=TRUE){

/*放置数据到静态缓冲*/
		strcpy(pTarget->asAccNbr[iCurPos],		p->sAccNbr);
		strcpy(pTarget->asBillingTypeID[iCurPos],	p->sBillingTypeID);

		pTarget->aiServiceTypeID[iCurPos]=		p->iServiceTypeID;

		strcpy(pTarget->asRelationType[iCurPos],	p->sRelationType);

		pTarget->aiUsage[iCurPos]=			p->iUsage;
		pTarget->aiWeight[iCurPos]=			p->iWeight;

		iCurPos++;
	}

	if(iInsertFlag==TRUE||iCurPos==CR_USER_BILL_SERVICE_TYPE_RLT_BUFLEN_OUT){

/* INSERT */
		char statement[8192];

		if(iCurPos==0) return 0;

		sprintf(statement,"\n\
			INSERT INTO %s(\n\
				ACC_NBR,\n\
				BILLING_TYPE_ID,\n\
				SERVICE_TYPE_ID,\n\
				RELATION_TYPE,\n\
				USAGE,\n\
				WEIGHT)\n\
			VALUES (\n\
				:asAccNbr,\n\
				:asBillingTypeID,\n\
				:aiServiceTypeID,\n\
				:asRelationType,\n\
				:aiUsage,\n\
				:aiWeight\n\
			)",sTableName);

		EXEC SQL PREPARE CR_USER_BILL_SERVICE_TYPE_RLTTRG FROM :statement;
		if(CheckSqlResult("Prepare insert statement CR_USER_BILL_SERVICE_TYPE_RLT")<0) return -1;

		EXEC SQL FOR :iCurPos EXECUTE CR_USER_BILL_SERVICE_TYPE_RLTTRG USING
				:pTarget->asAccNbr,
				:pTarget->asBillingTypeID,
				:pTarget->aiServiceTypeID,
				:pTarget->asRelationType,
				:pTarget->aiUsage,
				:pTarget->aiWeight;
		if(CheckSqlResult("Dyn insert into CR_USER_BILL_SERVICE_TYPE_RLT")<0) return -1;

		iCurPos=0;
	}

	pTarget->iCurPos=iCurPos;
	return 0;
}

/*批量数据动态从CR_USER_BILL_PATTERN_RLT中用结构缓冲方式取数据*/
int EGetCrUserBillPatternRltToStruct(struct CrUserBillPatternRltStruct *p,
	struct CrUserBillPatternRltStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(ACC_NBR,' '),\n\
				nvl(SUBSCRIPTION_ID,0),\n\
				nvl(BILLING_TYPE_ID,' '),\n\
				nvl(PATTERN_ID,0),\n\
				nvl(RELATION_TYPE,' '),\n\
				nvl(USAGE,0),\n\
				nvl(WEIGHT,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_USER_BILL_PATTERN_RLTSCR FROM :statement;
		CheckSqlError(" PREPARE CR_USER_BILL_PATTERN_RLTSCR CR_USER_BILL_PATTERN_RLTCR");

		EXEC SQL DECLARE CR_USER_BILL_PATTERN_RLTCR CURSOR FOR CR_USER_BILL_PATTERN_RLTSCR;
		CheckSqlError("Declare CR_USER_BILL_PATTERN_RLTCR");

		EXEC SQL OPEN CR_USER_BILL_PATTERN_RLTCR;
		CheckSqlError("Open CR_USER_BILL_PATTERN_RLTCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_USER_BILL_PATTERN_RLTCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_USER_BILL_PATTERN_RLTCR INTO
			:pSource->asAccNbr,
			:pSource->aiSubscriptionID,
			:pSource->asBillingTypeID,
			:pSource->aiPatternID,
			:pSource->asRelationType,
			:pSource->aiUsage,
			:pSource->aiWeight;
		CheckSqlError("Fetch CR_USER_BILL_PATTERN_RLTCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_USER_BILL_PATTERN_RLTCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_USER_BILL_PATTERN_RLT_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sAccNbr,		pSource->asAccNbr[iCurPos]);
		p->iSubscriptionID=		pSource->aiSubscriptionID[iCurPos];
		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);

		p->iPatternID=			pSource->aiPatternID[iCurPos];

		strcpy(p->sRelationType,	pSource->asRelationType[iCurPos]);

		p->iUsage=			pSource->aiUsage[iCurPos];
		p->iWeight=			pSource->aiWeight[iCurPos];

		AllTrim(p->sAccNbr);
		AllTrim(p->sBillingTypeID);
		AllTrim(p->sRelationType);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_USER_BILL_PATTERN_RLT的链表释放函数**/
void DestroyCrUserBillPatternRlt(struct CrUserBillPatternRltStruct *ptHead)
{
	struct CrUserBillPatternRltStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrUserBillPatternRlt(struct CrUserBillPatternRltStruct **pptHead)
{
	int iCnt=0;
	static struct CrUserBillPatternRltStruct *pTemp,*ptHead=NULL;
	struct CrUserBillPatternRltStruct Temp;
	struct CrUserBillPatternRltStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrUserBillPatternRlt(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrUserBillPatternRltStructIn));
	sprintf(TempIn.sTableName,"CR_USER_BILL_PATTERN_RLT");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrUserBillPatternRltToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrUserBillPatternRltStruct*)
			malloc(sizeof(struct CrUserBillPatternRltStruct)))==NULL){

			DestroyCrUserBillPatternRlt(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrUserBillPatternRltStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_USER_BILL_PATTERN_RLT记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_USER_BILL_PATTERN_RLT完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据结构缓冲写入CR_USER_BILL_PATTERN_RLT*/
int EInsertStructToCrUserBillPatternRlt(struct CrUserBillPatternRltStruct *p,
	int iInsertFlag,struct CrUserBillPatternRltStructOut *pTarget)
{

	int  iCurPos=pTarget->iCurPos;
	char *sTableName=pTarget->sTableName;

	if(iInsertFlag!=TRUE){

/*放置数据到静态缓冲*/
		strcpy(pTarget->asAccNbr[iCurPos],		p->sAccNbr);
		strcpy(pTarget->asBillingTypeID[iCurPos],	p->sBillingTypeID);

		pTarget->aiPatternID[iCurPos]=			p->iPatternID;

		strcpy(pTarget->asRelationType[iCurPos],	p->sRelationType);

		pTarget->aiUsage[iCurPos]=			p->iUsage;
		pTarget->aiWeight[iCurPos]=			p->iWeight;

		iCurPos++;
	}

	if(iInsertFlag==TRUE||iCurPos==CR_USER_BILL_PATTERN_RLT_BUFLEN_OUT){

/* INSERT */
		char statement[8192];

		if(iCurPos==0) return 0;

		sprintf(statement,"\n\
			INSERT INTO %s(\n\
				ACC_NBR,\n\
				BILLING_TYPE_ID,\n\
				PATTERN_ID,\n\
				RELATION_TYPE,\n\
				USAGE,\n\
				WEIGHT)\n\
			VALUES (\n\
				:asAccNbr,\n\
				:asBillingTypeID,\n\
				:aiPatternID,\n\
				:asRelationType,\n\
				:aiUsage,\n\
				:aiWeight\n\
			)",sTableName);

		EXEC SQL PREPARE CR_USER_BILL_PATTERN_RLTTRG FROM :statement;
		if(CheckSqlResult("Prepare insert statement CR_USER_BILL_PATTERN_RLT")<0) return -1;

		EXEC SQL FOR :iCurPos EXECUTE CR_USER_BILL_PATTERN_RLTTRG USING
				:pTarget->asAccNbr,
				:pTarget->asBillingTypeID,
				:pTarget->aiPatternID,
				:pTarget->asRelationType,
				:pTarget->aiUsage,
				:pTarget->aiWeight;
		if(CheckSqlResult("Dyn insert into CR_USER_BILL_PATTERN_RLT")<0) return -1;

		iCurPos=0;
	}

	pTarget->iCurPos=iCurPos;
	return 0;
}

void mvitem_fmcrmsisdnstat(struct FCrMsisdnStatStruct *pi,struct CrMsisdnStatStruct *po)
{/*数据文件移动到内存部分*/
	char sTemp[128];
	int i=0;

	bzero((void*)po,sizeof(struct CrMsisdnStatStruct));

		strncpy(po->sMsisdn,		pi->sMsisdn,20);
		strncpy(po->sAreaCode,		pi->sAreaCode,9);

		strncpy(sTemp,	pi->sSubscriptionID,9);sTemp[9]=0;
		po->iSubscriptionID=atoi(sTemp);

		strncpy(po->sBillingTypeID,	pi->sBillingTypeID,20);
		strncpy(po->sServiceType,	pi->sServiceType,10);

		strncpy(sTemp,		pi->sIndexID,4);sTemp[4]=0;
		po->iIndexID=atoi(sTemp);
		strncpy(sTemp,		pi->sTotalCnt,9);sTemp[9]=0;
		po->iTotalCnt=atoi(sTemp);

		strncpy(sTemp,		pi->sVolume,12);sTemp[12]=0;
		po->iVolume=atoi(sTemp);
		
		strncpy(po->sVolumeUnit,	pi->sVolumeUnit,1);
		
		strncpy(sTemp,		pi->sCharge,12);sTemp[12]=0;
		po->iCharge=atoi(sTemp);
		strncpy(sTemp,		pi->sRate,8);sTemp[8]=0;
		po->dRate=atof(sTemp);

		strncpy(po->sRateUnit,		pi->sRateUnit,1);

		strncpy(po->sXGradeID,		pi->sXGradeID,6);po->sXGradeID[6]=0;
		strncpy(sTemp,		pi->sWeight,4);sTemp[4]=0;
		po->iWeight=atoi(sTemp);
		
		AllTrim(po->sMsisdn);
		AllTrim(po->sAreaCode);
		AllTrim(po->sBillingTypeID);
		AllTrim(po->sServiceType);
		AllTrim(po->sVolumeUnit);
		AllTrim(po->sRateUnit);
		AllTrim(po->sXGradeID);
		i=strlen(po->sAreaCode);
		strcpy(sTemp,po->sAreaCode);
		if(i==0) strcpy(po->sAreaCode,"591");
		else if(i==1)sprintf(po->sAreaCode,"59%s",sTemp);
		else if(i==2)sprintf(po->sAreaCode,"5%s",sTemp);
}
void mvitem_mfcrmsisdnstat(struct CrMsisdnStatStruct *pi,struct FCrMsisdnStatStruct *po)
{/*内存数据移动到文件记录到部分*/
	char sTemp[128];

	memset((void*)po,' ',sizeof(struct FCrMsisdnStatStruct));

		strncpy(po->sMsisdn,pi->sMsisdn,strlen(pi->sMsisdn));
		strncpy(po->sAreaCode,pi->sAreaCode,strlen(pi->sAreaCode));

		sprintf(sTemp,"%09d",pi->iSubscriptionID);
		strncpy(po->sSubscriptionID,sTemp,9);

		strncpy(po->sBillingTypeID,pi->sBillingTypeID,strlen(pi->sBillingTypeID));
		strncpy(po->sServiceType,pi->sServiceType,strlen(pi->sServiceType));

		sprintf(sTemp,"%04d",pi->iIndexID);
		strncpy(po->sIndexID,sTemp,4);
		sprintf(sTemp,"%09d",pi->iTotalCnt);
		strncpy(po->sTotalCnt,sTemp,9);

		sprintf(sTemp,"%012d",pi->iVolume);
		strncpy(po->sVolume,sTemp,12);
		strncpy(po->sVolumeUnit,pi->sVolumeUnit,strlen(pi->sVolumeUnit));
		
		sprintf(sTemp,"%012d",pi->iCharge);
		strncpy(po->sCharge,sTemp,12);

		sprintf(sTemp,"%012lf",pi->dRate);
		strncpy(po->sRate,sTemp,12);

		strncpy(po->sRateUnit,pi->sRateUnit,strlen(pi->sRateUnit));

		strncpy(po->sXGradeID,pi->sXGradeID,6);
		sprintf(sTemp,"%04d",pi->iWeight);
		strncpy(po->sWeight,sTemp,4);

}




#ifdef MODEL_EGET

/*批量数据动态从CR_MSISDN_STAT中用结构缓冲方式取数据*/
int EGetCrMsisdnStatToStruct(struct CrMsisdnStatStruct *p,
	struct CrMsisdnStatStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(MSISDN,' '),\n\
				nvl(AREA_CODE,' '),\n\
				nvl(SUBSCRIPTION_ID,0),\n\
				nvl(BILLING_TYPE_ID,' '),\n\
				nvl(SERVICE_TYPE,' '),\n\
				nvl(INDEX_ID,0),\n\
				nvl(TOTAL_CNT,0),\n\
				to_char(nvl(AMOUNT,0)),\n\
				nvl(AMOUNT_UNIT,' '),\n\
				to_char(nvl(CHARGE,0)),\n\
				nvl(RATE,0),\n\
				nvl(RATE_UNIT,' '),\n\
				nvl(X_GRADE_ID,0),\n\
				nvl(WEIGHT,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_MSISDN_STATSCR FROM :statement;
		CheckSqlError(" PREPARE CR_MSISDN_STATSCR CR_MSISDN_STATCR");

		EXEC SQL DECLARE CR_MSISDN_STATCR CURSOR FOR CR_MSISDN_STATSCR;
		CheckSqlError("Declare CR_MSISDN_STATCR");

		EXEC SQL OPEN CR_MSISDN_STATCR;
		CheckSqlError("Open CR_MSISDN_STATCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_MSISDN_STATCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_MSISDN_STATCR INTO
			:pSource->asMsisdn,
			:pSource->asAreaCode,
			:pSource->aiSubscriptionID,
			:pSource->asBillingTypeID,
			:pSource->asServiceType,
			:pSource->aiIndexID,
			:pSource->aiTotalCnt,
			:pSource->asAmount,
			:pSource->asAmountUnit,
			:pSource->asCharge,
			:pSource->aiRate,
			:pSource->asRateUnit,
			:pSource->aiXGradeID,
			:pSource->aiWeight;
		CheckSqlError("Fetch CR_MSISDN_STATCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_MSISDN_STATCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_MSISDN_STAT_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sMsisdn,		pSource->asMsisdn[iCurPos]);
		strcpy(p->sAreaCode,		pSource->asAreaCode[iCurPos]);

		p->iSubscriptionID=		pSource->aiSubscriptionID[iCurPos];

		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);
		strcpy(p->sServiceType,		pSource->asServiceType[iCurPos]);

		p->iIndexID=			pSource->aiIndexID[iCurPos];
		p->iTotalCnt=			pSource->aiTotalCnt[iCurPos];

		strcpy(p->sAmount,		pSource->asAmount[iCurPos]);
		strcpy(p->sAmountUnit,		pSource->asAmountUnit[iCurPos]);
		strcpy(p->sCharge,		pSource->asCharge[iCurPos]);

		p->iRate=			pSource->aiRate[iCurPos];

		strcpy(p->sRateUnit,		pSource->asRateUnit[iCurPos]);

		p->iXGradeID=			pSource->aiXGradeID[iCurPos];
		p->iWeight=			pSource->aiWeight[iCurPos];

		AllTrim(p->sMsisdn);
		AllTrim(p->sAreaCode);
		AllTrim(p->sBillingTypeID);
		AllTrim(p->sServiceType);
		AllTrim(p->sAmount);
		AllTrim(p->sAmountUnit);
		AllTrim(p->sCharge);
		AllTrim(p->sRateUnit);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_MSISDN_STAT的链表释放函数**/
void DestroyCrMsisdnStat(struct CrMsisdnStatStruct *ptHead)
{
	struct CrMsisdnStatStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
/*批量数据结构缓冲写入CR_MSISDN_STAT*/
int EInsertStructToCrMsisdnStat(struct CrMsisdnStatStruct *p,
	int iInsertFlag,struct CrMsisdnStatStructOut *pTarget)
{

	int  iCurPos=pTarget->iCurPos;
	char *sTableName=pTarget->sTableName;

	if(iInsertFlag!=TRUE){

/*放置数据到静态缓冲*/
		strcpy(pTarget->asMsisdn[iCurPos],		p->sMsisdn);
		strcpy(pTarget->asAreaCode[iCurPos],		p->sAreaCode);

		pTarget->aiSubscriptionID[iCurPos]=		p->iSubscriptionID;

		strcpy(pTarget->asBillingTypeID[iCurPos],	p->sBillingTypeID);
		strcpy(pTarget->asServiceType[iCurPos],		p->sServiceType);

		pTarget->aiIndexID[iCurPos]=			p->iIndexID;
		pTarget->aiTotalCnt[iCurPos]=			p->iTotalCnt;

		strcpy(pTarget->asAmount[iCurPos],		p->sAmount);
		strcpy(pTarget->asAmountUnit[iCurPos],		p->sAmountUnit);
		strcpy(pTarget->asCharge[iCurPos],		p->sCharge);

		pTarget->aiRate[iCurPos]=			p->iRate;

		strcpy(pTarget->asRateUnit[iCurPos],		p->sRateUnit);

		pTarget->aiXGradeID[iCurPos]=			p->iXGradeID;
		pTarget->aiWeight[iCurPos]=			p->iWeight;

		iCurPos++;
	}

	if(iInsertFlag==TRUE||iCurPos==CR_MSISDN_STAT_BUFLEN_OUT){

/* INSERT */
		char statement[8192];

		if(iCurPos==0) return 0;

		sprintf(statement,"\n\
			INSERT INTO %s(\n\
				MSISDN,\n\
				AREA_CODE,\n\
				SUBSCRIPTION_ID,\n\
				BILLING_TYPE_ID,\n\
				SERVICE_TYPE,\n\
				INDEX_ID,\n\
				TOTAL_CNT,\n\
				AMOUNT,\n\
				AMOUNT_UNIT,\n\
				CHARGE,\n\
				RATE,\n\
				RATE_UNIT,\n\
				X_GRADE_ID,\n\
				WEIGHT)\n\
			VALUES (\n\
				:asMsisdn,\n\
				:asAreaCode,\n\
				:aiSubscriptionID,\n\
				:asBillingTypeID,\n\
				:asServiceType,\n\
				:aiIndexID,\n\
				:aiTotalCnt,\n\
				to_number(:asAmount),\n\
				:asAmountUnit,\n\
				to_number(:asCharge),\n\
				:aiRate,\n\
				:asRateUnit,\n\
				:aiXGradeID,\n\
				:aiWeight\n\
			)",sTableName);

		EXEC SQL PREPARE CR_MSISDN_STATTRG FROM :statement;
		if(CheckSqlResult("Prepare insert statement CR_MSISDN_STAT")<0) return -1;

		EXEC SQL FOR :iCurPos EXECUTE CR_MSISDN_STATTRG USING
				:pTarget->asMsisdn,
				:pTarget->asAreaCode,
				:pTarget->aiSubscriptionID,
				:pTarget->asBillingTypeID,
				:pTarget->asServiceType,
				:pTarget->aiIndexID,
				:pTarget->aiTotalCnt,
				:pTarget->asAmount,
				:pTarget->asAmountUnit,
				:pTarget->asCharge,
				:pTarget->aiRate,
				:pTarget->asRateUnit,
				:pTarget->aiXGradeID,
				:pTarget->aiWeight;
		if(CheckSqlResult("Dyn insert into CR_MSISDN_STAT")<0) return -1;

		iCurPos=0;
	}

	pTarget->iCurPos=iCurPos;
	return 0;
}
/*批量数据动态从CR_BILLING_TYPE_STAT中用结构缓冲方式取数据*/
int EGetCrBillingTypeStatToStruct(struct CrBillingTypeStatStruct *p,
	struct CrBillingTypeStatStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				to_char(nvl(CR_BILLING_TYPE_STAT_ID,0)),\n\
				nvl(BILLING_TYPE_ID,' '),\n\
				nvl(AREA_CODE,' '),\n\
				nvl(SERVICE_TYPE,' '),\n\
				nvl(INDEX_ID,0),\n\
				nvl(TOTAL_CNT,0),\n\
				to_char(nvl(AMOUNT,0)),\n\
				nvl(AMOUNT_UNIT,' '),\n\
				to_char(nvl(CHARGE,0)),\n\
				nvl(RATE,0),\n\
				nvl(RATE_UNIT,' '),\n\
				nvl(X_GRADE_ID,0),\n\
				nvl(Y_GRADE_ID,0),\n\
				nvl(WEIGHT,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_BILLING_TYPE_STATSCR FROM :statement;
		CheckSqlError(" PREPARE CR_BILLING_TYPE_STATSCR CR_BILLING_TYPE_STATCR");

		EXEC SQL DECLARE CR_BILLING_TYPE_STATCR CURSOR FOR CR_BILLING_TYPE_STATSCR;
		CheckSqlError("Declare CR_BILLING_TYPE_STATCR");

		EXEC SQL OPEN CR_BILLING_TYPE_STATCR;
		CheckSqlError("Open CR_BILLING_TYPE_STATCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_BILLING_TYPE_STATCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_BILLING_TYPE_STATCR INTO
			:pSource->asCrBillingTypeStatID,
			:pSource->asBillingTypeID,
			:pSource->asAreaCode,
			:pSource->asServiceType,
			:pSource->aiIndexID,
			:pSource->aiTotalCnt,
			:pSource->asAmount,
			:pSource->asAmountUnit,
			:pSource->asCharge,
			:pSource->aiRate,
			:pSource->asRateUnit,
			:pSource->aiXGradeID,
			:pSource->aiYGradeID,
			:pSource->aiWeight;
		CheckSqlError("Fetch CR_BILLING_TYPE_STATCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_BILLING_TYPE_STATCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_BILLING_TYPE_STAT_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sCrBillingTypeStatID,	pSource->asCrBillingTypeStatID[iCurPos]);
		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);
		strcpy(p->sAreaCode,		pSource->asAreaCode[iCurPos]);
		strcpy(p->sServiceType,		pSource->asServiceType[iCurPos]);

		p->iIndexID=			pSource->aiIndexID[iCurPos];
		p->iTotalCnt=			pSource->aiTotalCnt[iCurPos];

		strcpy(p->sAmount,		pSource->asAmount[iCurPos]);
		strcpy(p->sAmountUnit,		pSource->asAmountUnit[iCurPos]);
		strcpy(p->sCharge,		pSource->asCharge[iCurPos]);

		p->iRate=			pSource->aiRate[iCurPos];

		strcpy(p->sRateUnit,		pSource->asRateUnit[iCurPos]);

		p->iXGradeID=			pSource->aiXGradeID[iCurPos];
		p->iYGradeID=			pSource->aiYGradeID[iCurPos];
		p->iWeight=			pSource->aiWeight[iCurPos];

		AllTrim(p->sCrBillingTypeStatID);
		AllTrim(p->sBillingTypeID);
		AllTrim(p->sAreaCode);
		AllTrim(p->sServiceType);
		AllTrim(p->sAmount);
		AllTrim(p->sAmountUnit);
		AllTrim(p->sCharge);
		AllTrim(p->sRateUnit);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_BILLING_TYPE_STAT的链表释放函数**/
void DestroyCrBillingTypeStat(struct CrBillingTypeStatStruct *ptHead)
{
	struct CrBillingTypeStatStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
/*批量数据结构缓冲写入CR_BILLING_TYPE_STAT*/
int EInsertStructToCrBillingTypeStat(struct CrBillingTypeStatStruct *p,
	int iInsertFlag,struct CrBillingTypeStatStructOut *pTarget)
{

	int  iCurPos=pTarget->iCurPos;
	char *sTableName=pTarget->sTableName;

	if(iInsertFlag!=TRUE){

/*放置数据到静态缓冲*/
		strcpy(pTarget->asCrBillingTypeStatID[iCurPos],	p->sCrBillingTypeStatID);
		strcpy(pTarget->asBillingTypeID[iCurPos],	p->sBillingTypeID);
		strcpy(pTarget->asAreaCode[iCurPos],		p->sAreaCode);
		strcpy(pTarget->asServiceType[iCurPos],		p->sServiceType);

		pTarget->aiIndexID[iCurPos]=			p->iIndexID;
		pTarget->aiTotalCnt[iCurPos]=			p->iTotalCnt;

		strcpy(pTarget->asAmount[iCurPos],		p->sAmount);
		strcpy(pTarget->asAmountUnit[iCurPos],		p->sAmountUnit);
		strcpy(pTarget->asCharge[iCurPos],		p->sCharge);

		pTarget->aiRate[iCurPos]=			p->iRate;

		strcpy(pTarget->asRateUnit[iCurPos],		p->sRateUnit);

		pTarget->aiXGradeID[iCurPos]=			p->iXGradeID;
		pTarget->aiYGradeID[iCurPos]=			p->iYGradeID;
		pTarget->aiWeight[iCurPos]=			p->iWeight;

		iCurPos++;
	}

	if(iInsertFlag==TRUE||iCurPos==CR_BILLING_TYPE_STAT_BUFLEN_OUT){

/* INSERT */
		char statement[8192];

		if(iCurPos==0) return 0;

		sprintf(statement,"\n\
			INSERT INTO %s(\n\
				CR_BILLING_TYPE_STAT_ID,\n\
				BILLING_TYPE_ID,\n\
				AREA_CODE,\n\
				SERVICE_TYPE,\n\
				INDEX_ID,\n\
				TOTAL_CNT,\n\
				AMOUNT,\n\
				AMOUNT_UNIT,\n\
				CHARGE,\n\
				RATE,\n\
				RATE_UNIT,\n\
				X_GRADE_ID,\n\
				Y_GRADE_ID,\n\
				WEIGHT)\n\
			VALUES (\n\
				to_number(:asCrBillingTypeStatID),\n\
				:asBillingTypeID,\n\
				:asAreaCode,\n\
				:asServiceType,\n\
				:aiIndexID,\n\
				:aiTotalCnt,\n\
				to_number(:asAmount),\n\
				:asAmountUnit,\n\
				to_number(:asCharge),\n\
				:aiRate,\n\
				:asRateUnit,\n\
				:aiXGradeID,\n\
				:aiYGradeID,\n\
				:aiWeight\n\
			)",sTableName);

		EXEC SQL PREPARE CR_BILLING_TYPE_STATTRG FROM :statement;
		if(CheckSqlResult("Prepare insert statement CR_BILLING_TYPE_STAT")<0) return -1;

		EXEC SQL FOR :iCurPos EXECUTE CR_BILLING_TYPE_STATTRG USING
				:pTarget->asCrBillingTypeStatID,
				:pTarget->asBillingTypeID,
				:pTarget->asAreaCode,
				:pTarget->asServiceType,
				:pTarget->aiIndexID,
				:pTarget->aiTotalCnt,
				:pTarget->asAmount,
				:pTarget->asAmountUnit,
				:pTarget->asCharge,
				:pTarget->aiRate,
				:pTarget->asRateUnit,
				:pTarget->aiXGradeID,
				:pTarget->aiYGradeID,
				:pTarget->aiWeight;
		if(CheckSqlResult("Dyn insert into CR_BILLING_TYPE_STAT")<0) return -1;

		iCurPos=0;
	}

	pTarget->iCurPos=iCurPos;
	return 0;
}
#endif

/*批量数据动态从CR_ACCT_ITEM_TYPE中用结构缓冲方式取数据*/
int EGetCrAcctItemTypeToStruct(struct CrAcctItemTypeStruct *p,
	struct CrAcctItemTypeStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(ACCT_ITEM_TYPE_ID,0),\n\
				ACCT_ITEM_NAME,\n\
				nvl(SERVICE_TYPE,' '),\n\
				nvl(SUB_SERVICE_CODE,' '),\n\
				nvl(APPORTION_TYPE,' '),\n\
				nvl(PRIORITY,0),\n\
				nvl(FEE_SEQ,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_ACCT_ITEM_TYPESCR FROM :statement;
		CheckSqlError(" PREPARE CR_ACCT_ITEM_TYPESCR CR_ACCT_ITEM_TYPECR");

		EXEC SQL DECLARE CR_ACCT_ITEM_TYPECR CURSOR FOR CR_ACCT_ITEM_TYPESCR;
		CheckSqlError("Declare CR_ACCT_ITEM_TYPECR");

		EXEC SQL OPEN CR_ACCT_ITEM_TYPECR;
		CheckSqlError("Open CR_ACCT_ITEM_TYPECR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_ACCT_ITEM_TYPECR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_ACCT_ITEM_TYPECR INTO
			:pSource->aiAcctItemTypeID,
			:pSource->asAcctItemName,
			:pSource->asServiceType,
			:pSource->asSubServiceCode,
			:pSource->asApportionType,
			:pSource->aiPriority,
			:pSource->aiFeeSeq;
		CheckSqlError("Fetch CR_ACCT_ITEM_TYPECR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_ACCT_ITEM_TYPECR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_ACCT_ITEM_TYPE_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iAcctItemTypeID=		pSource->aiAcctItemTypeID[iCurPos];

		strcpy(p->sAcctItemName,	pSource->asAcctItemName[iCurPos]);
		strcpy(p->sServiceType,		pSource->asServiceType[iCurPos]);
		strcpy(p->sSubServiceCode,	pSource->asSubServiceCode[iCurPos]);
		strcpy(p->sApportionType,	pSource->asApportionType[iCurPos]);

		p->iPriority=			pSource->aiPriority[iCurPos];
		p->iFeeSeq=			pSource->aiFeeSeq[iCurPos];

		AllTrim(p->sAcctItemName);
		AllTrim(p->sServiceType);
		AllTrim(p->sSubServiceCode);
		AllTrim(p->sApportionType);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_ACCT_ITEM_TYPE的链表释放函数**/
void DestroyCrAcctItemType(struct CrAcctItemTypeStruct *ptHead)
{
	struct CrAcctItemTypeStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrAcctItemType(struct CrAcctItemTypeStruct **pptHead)
{
	int iCnt=0;
	static struct CrAcctItemTypeStruct *pTemp,*ptHead=NULL;
	struct CrAcctItemTypeStruct Temp;
	struct CrAcctItemTypeStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrAcctItemType(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrAcctItemTypeStructIn));
	sprintf(TempIn.sTableName,"CR_ACCT_ITEM_TYPE");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrAcctItemTypeToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrAcctItemTypeStruct*)
			malloc(sizeof(struct CrAcctItemTypeStruct)))==NULL){

			DestroyCrAcctItemType(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrAcctItemTypeStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_ACCT_ITEM_TYPE记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_ACCT_ITEM_TYPE完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从CR_PROMISE_ACCT_RELATION中用结构缓冲方式取数据*/
int EGetCrPromiseAcctRelationToStruct(struct CrPromiseAcctRelationStruct *p,
	struct CrPromiseAcctRelationStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(PROMISE_ELEMENT_ID,0),\n\
				nvl(ACCT_ITEM_TYPE_ID,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_PROMISE_ACCT_RELATIONSCR FROM :statement;
		CheckSqlError(" PREPARE CR_PROMISE_ACCT_RELATIONSCR CR_PROMISE_ACCT_RELATIONCR");

		EXEC SQL DECLARE CR_PROMISE_ACCT_RELATIONCR CURSOR FOR CR_PROMISE_ACCT_RELATIONSCR;
		CheckSqlError("Declare CR_PROMISE_ACCT_RELATIONCR");

		EXEC SQL OPEN CR_PROMISE_ACCT_RELATIONCR;
		CheckSqlError("Open CR_PROMISE_ACCT_RELATIONCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_PROMISE_ACCT_RELATIONCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_PROMISE_ACCT_RELATIONCR INTO
			:pSource->aiPromiseElementID,
			:pSource->aiAcctItemTypeID;
		CheckSqlError("Fetch CR_PROMISE_ACCT_RELATIONCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_PROMISE_ACCT_RELATIONCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_PROMISE_ACCT_RELATION_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iPromiseElementID=	pSource->aiPromiseElementID[iCurPos];
		p->iAcctItemTypeID=	pSource->aiAcctItemTypeID[iCurPos];


	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_PROMISE_ACCT_RELATION的链表释放函数**/
void DestroyCrPromiseAcctRelation(struct CrPromiseAcctRelationStruct *ptHead)
{
	struct CrPromiseAcctRelationStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrPromiseAcctRelation(struct CrPromiseAcctRelationStruct **pptHead)
{
	int iCnt=0;
	static struct CrPromiseAcctRelationStruct *pTemp,*ptHead=NULL;
	struct CrPromiseAcctRelationStruct Temp;
	struct CrPromiseAcctRelationStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrPromiseAcctRelation(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrPromiseAcctRelationStructIn));
	sprintf(TempIn.sTableName,"CR_PROMISE_ACCT_RELATION");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrPromiseAcctRelationToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrPromiseAcctRelationStruct*)
			malloc(sizeof(struct CrPromiseAcctRelationStruct)))==NULL){

			DestroyCrPromiseAcctRelation(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrPromiseAcctRelationStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_PROMISE_ACCT_RELATION记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_PROMISE_ACCT_RELATION完毕总记录数%d",iCnt);

	return iCnt;
}
/*批量数据动态从CR_SUB_SERVICE_CODE中用结构缓冲方式取数据*/
int EGetCrSubServiceCodeToStruct(struct CrSubServiceCodeStruct *p,
	struct CrSubServiceCodeStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				SUB_SERVICE_ID,\n\
				SUB_SERVICE_CODE,\n\
				NAME,\n\
				nvl(SERVICE_TYPE,' ')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_SUB_SERVICE_CODESCR FROM :statement;
		CheckSqlError(" PREPARE CR_SUB_SERVICE_CODESCR CR_SUB_SERVICE_CODECR");

		EXEC SQL DECLARE CR_SUB_SERVICE_CODECR CURSOR FOR CR_SUB_SERVICE_CODESCR;
		CheckSqlError("Declare CR_SUB_SERVICE_CODECR");

		EXEC SQL OPEN CR_SUB_SERVICE_CODECR;
		CheckSqlError("Open CR_SUB_SERVICE_CODECR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_SUB_SERVICE_CODECR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_SUB_SERVICE_CODECR INTO
			:pSource->aiSubServiceID,
			:pSource->asSubServiceCode,
			:pSource->asName,
			:pSource->asServiceType;
		CheckSqlError("Fetch CR_SUB_SERVICE_CODECR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_SUB_SERVICE_CODECR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_SUB_SERVICE_CODE_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iSubServiceID=		pSource->aiSubServiceID[iCurPos];

		strcpy(p->sSubServiceCode,	pSource->asSubServiceCode[iCurPos]);
		strcpy(p->sName,		pSource->asName[iCurPos]);
		strcpy(p->sServiceType,		pSource->asServiceType[iCurPos]);

		AllTrim(p->sSubServiceCode);
		AllTrim(p->sName);
		AllTrim(p->sServiceType);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_SUB_SERVICE_CODE的链表释放函数**/
void DestroyCrSubServiceCode(struct CrSubServiceCodeStruct *ptHead)
{
	struct CrSubServiceCodeStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrSubServiceCode(struct CrSubServiceCodeStruct **pptHead)
{
	int iCnt=0;
	static struct CrSubServiceCodeStruct *pTemp,*ptHead=NULL;
	struct CrSubServiceCodeStruct Temp;
	struct CrSubServiceCodeStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrSubServiceCode(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrSubServiceCodeStructIn));
	sprintf(TempIn.sTableName,"CR_SUB_SERVICE_CODE");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrSubServiceCodeToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrSubServiceCodeStruct*)
			malloc(sizeof(struct CrSubServiceCodeStruct)))==NULL){

			DestroyCrSubServiceCode(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrSubServiceCodeStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_SUB_SERVICE_CODE记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_SUB_SERVICE_CODE完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从CR_ACCT_INDEX_RLT中用结构缓冲方式取数据*/
int EGetCrAcctIndexRltToStruct(struct CrAcctIndexRltStruct *p,
	struct CrAcctIndexRltStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(ACCT_ITEM_TYPE_ID,0),\n\
				nvl(INDEX_ID,0),\n\
				nvl(PERCENT,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_ACCT_INDEX_RLTSCR FROM :statement;
		CheckSqlError(" PREPARE CR_ACCT_INDEX_RLTSCR CR_ACCT_INDEX_RLTCR");

		EXEC SQL DECLARE CR_ACCT_INDEX_RLTCR CURSOR FOR CR_ACCT_INDEX_RLTSCR;
		CheckSqlError("Declare CR_ACCT_INDEX_RLTCR");

		EXEC SQL OPEN CR_ACCT_INDEX_RLTCR;
		CheckSqlError("Open CR_ACCT_INDEX_RLTCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_ACCT_INDEX_RLTCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_ACCT_INDEX_RLTCR INTO
			:pSource->aiAcctItemTypeID,
			:pSource->aiIndexID,
			:pSource->aiPercent;
		CheckSqlError("Fetch CR_ACCT_INDEX_RLTCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_ACCT_INDEX_RLTCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_ACCT_INDEX_RLT_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iAcctItemTypeID=		pSource->aiAcctItemTypeID[iCurPos];
		p->iIndexID=			pSource->aiIndexID[iCurPos];
		
		p->iPercent=			pSource->aiPercent[iCurPos];

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_ACCT_INDEX_RLT的链表释放函数**/
void DestroyCrAcctIndexRlt(struct CrAcctIndexRltStruct *ptHead)
{
	struct CrAcctIndexRltStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrAcctIndexRlt(struct CrAcctIndexRltStruct **pptHead)
{
	int iCnt=0;
	static struct CrAcctIndexRltStruct *pTemp,*ptHead=NULL;
	struct CrAcctIndexRltStruct Temp;
	struct CrAcctIndexRltStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrAcctIndexRlt(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrAcctIndexRltStructIn));
	sprintf(TempIn.sTableName,"CR_ACCT_INDEX_RLT");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrAcctIndexRltToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrAcctIndexRltStruct*)
			malloc(sizeof(struct CrAcctIndexRltStruct)))==NULL){

			DestroyCrAcctIndexRlt(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrAcctIndexRltStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_ACCT_INDEX_RLT记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_ACCT_INDEX_RLT完毕总记录数%d",iCnt);

	return iCnt;
}
/*获取CR_MSISDN_STAT_SEQ序列号*/
int GetCrMsisdnStatSeq()
{
	int iCrMsisdnStat=0;
	
	EXEC SQL SELECT CR_MSISDN_STAT_SEQ.nextval INTO :iCrMsisdnStat FROM DUAL ;
	CheckSqlError("Get CR_MSISDN_STAT_SEQ ERROR");
	
	return iCrMsisdnStat;
	
}
/*获取CR_BILL_TYPE_STAT_SEQ序列号*/
int GetCrBillingTypeStatSeq()
{
	int iCrBillTypeStat=0;
	
	EXEC SQL SELECT CR_BILLING_TYPE_STAT_SEQ.nextval INTO :iCrBillTypeStat FROM DUAL ;
	CheckSqlError("Get CR_BILL_TYPE_STAT_SEQ ERROR");
	
	return iCrBillTypeStat;
	
}
/*批量数据动态从CR_INDEX_GRADE_DESC中用结构缓冲方式取数据*/
int EGetCrIndexGradeDescToStruct(struct CrIndexGradeDescStruct *p,
	struct CrIndexGradeDescStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				GRADE_ID,\n\
				NAME,\n\
				nvl(REMARK,' '),\n\
				INDEX_ID,\n\
				TYPE,\n\
				BGN_VAL,\n\
				END_VAL\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_INDEX_GRADE_DESCSCR FROM :statement;
		CheckSqlError(" PREPARE CR_INDEX_GRADE_DESCSCR CR_INDEX_GRADE_DESCCR");

		EXEC SQL DECLARE CR_INDEX_GRADE_DESCCR CURSOR FOR CR_INDEX_GRADE_DESCSCR;
		CheckSqlError("Declare CR_INDEX_GRADE_DESCCR");

		EXEC SQL OPEN CR_INDEX_GRADE_DESCCR;
		CheckSqlError("Open CR_INDEX_GRADE_DESCCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_INDEX_GRADE_DESCCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_INDEX_GRADE_DESCCR INTO
			:pSource->asGradeID,
			:pSource->asName,
			:pSource->asRemark,
			:pSource->aiIndexID,
			:pSource->asType,
			:pSource->aiBgnVal,
			:pSource->aiEndVal;
		CheckSqlError("Fetch CR_INDEX_GRADE_DESCCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_INDEX_GRADE_DESCCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_INDEX_GRADE_DESC_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sGradeID,	pSource->asGradeID[iCurPos]);
		strcpy(p->sName,	pSource->asName[iCurPos]);
		strcpy(p->sRemark,	pSource->asRemark[iCurPos]);

		p->iIndexID=		pSource->aiIndexID[iCurPos];

		strcpy(p->sType,	pSource->asType[iCurPos]);

		p->iBgnVal=		pSource->aiBgnVal[iCurPos];
		p->iEndVal=		pSource->aiEndVal[iCurPos];

		AllTrim(p->sGradeID);
		AllTrim(p->sName);
		AllTrim(p->sRemark);
		AllTrim(p->sType);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_INDEX_GRADE_DESC的链表释放函数**/
void DestroyCrIndexGradeDesc(struct CrIndexGradeDescStruct *ptHead)
{
	struct CrIndexGradeDescStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrIndexGradeDesc(struct CrIndexGradeDescStruct **pptHead)
{
	int iCnt=0;
	static struct CrIndexGradeDescStruct *pTemp,*ptHead=NULL;
	struct CrIndexGradeDescStruct Temp;
	struct CrIndexGradeDescStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrIndexGradeDesc(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrIndexGradeDescStructIn));
	sprintf(TempIn.sTableName,"CR_INDEX_GRADE_DESC");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrIndexGradeDescToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrIndexGradeDescStruct*)
			malloc(sizeof(struct CrIndexGradeDescStruct)))==NULL){

			DestroyCrIndexGradeDesc(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrIndexGradeDescStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_INDEX_GRADE_DESC记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_INDEX_GRADE_DESC完毕总记录数%d",iCnt);

	return iCnt;
}
/*批量数据动态从CR_BILL_TYPE_ACCT_APPR中用结构缓冲方式取数据*/
int EGetCrBillTypeAcctApprToStruct(struct CrBillTypeAcctApprStruct *p,
	struct CrBillTypeAcctApprStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				ACCT_ITEM_TYPE_ID,\n\
				nvl(BILLING_TYPE_ID,' '),\n\
				APPR_ID,\n\
				METHOD,\n\
				nvl(PARAM_STR,' ')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_BILL_TYPE_ACCT_APPRSCR FROM :statement;
		CheckSqlError(" PREPARE CR_BILL_TYPE_ACCT_APPRSCR CR_BILL_TYPE_ACCT_APPRCR");

		EXEC SQL DECLARE CR_BILL_TYPE_ACCT_APPRCR CURSOR FOR CR_BILL_TYPE_ACCT_APPRSCR;
		CheckSqlError("Declare CR_BILL_TYPE_ACCT_APPRCR");

		EXEC SQL OPEN CR_BILL_TYPE_ACCT_APPRCR;
		CheckSqlError("Open CR_BILL_TYPE_ACCT_APPRCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_BILL_TYPE_ACCT_APPRCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_BILL_TYPE_ACCT_APPRCR INTO
			:pSource->aiAcctItemTypeID,
			:pSource->asBillingTypeID,
			:pSource->aiApprID,
			:pSource->asMethod,
			:pSource->asParamStr;
		CheckSqlError("Fetch CR_BILL_TYPE_ACCT_APPRCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_BILL_TYPE_ACCT_APPRCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_BILL_TYPE_ACCT_APPR_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iAcctItemTypeID=		pSource->aiAcctItemTypeID[iCurPos];

		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);

		p->iApprID=			pSource->aiApprID[iCurPos];

		strcpy(p->sMethod,		pSource->asMethod[iCurPos]);
		strcpy(p->sParamStr,		pSource->asParamStr[iCurPos]);

		AllTrim(p->sBillingTypeID);
		AllTrim(p->sMethod);
		AllTrim(p->sParamStr);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_BILL_TYPE_ACCT_APPR的链表释放函数**/
void DestroyCrBillTypeAcctAppr(struct CrBillTypeAcctApprStruct *ptHead)
{
	struct CrBillTypeAcctApprStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrBillTypeAcctAppr(struct CrBillTypeAcctApprStruct **pptHead)
{
	int iCnt=0;
	static struct CrBillTypeAcctApprStruct *pTemp,*ptHead=NULL;
	struct CrBillTypeAcctApprStruct Temp;
	struct CrBillTypeAcctApprStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrBillTypeAcctAppr(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrBillTypeAcctApprStructIn));
	sprintf(TempIn.sTableName,"CR_BILL_TYPE_ACCT_APPR");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrBillTypeAcctApprToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrBillTypeAcctApprStruct*)
			malloc(sizeof(struct CrBillTypeAcctApprStruct)))==NULL){

			DestroyCrBillTypeAcctAppr(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrBillTypeAcctApprStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_BILL_TYPE_ACCT_APPR记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_BILL_TYPE_ACCT_APPR完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从CR_BILL_TYPE_ACCT_APPR_PARAM中用结构缓冲方式取数据*/
int EGetCrBillTypeAcctApprParamToStruct(struct CrBillTypeAcctApprParamStruct *p,
	struct CrBillTypeAcctApprParamStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				INDEX_ID,\n\
				APPR_ID,\n\
				nvl(PERCENT,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_BILL_TYPE_ACCT_APPR_PARAMSCR FROM :statement;
		CheckSqlError(" PREPARE CR_BILL_TYPE_ACCT_APPR_PARAMSCR CR_BILL_TYPE_ACCT_APPR_PARAMCR");

		EXEC SQL DECLARE CR_BILL_TYPE_ACCT_APPR_PARAMCR CURSOR FOR CR_BILL_TYPE_ACCT_APPR_PARAMSCR;
		CheckSqlError("Declare CR_BILL_TYPE_ACCT_APPR_PARAMCR");

		EXEC SQL OPEN CR_BILL_TYPE_ACCT_APPR_PARAMCR;
		CheckSqlError("Open CR_BILL_TYPE_ACCT_APPR_PARAMCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_BILL_TYPE_ACCT_APPR_PARAMCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_BILL_TYPE_ACCT_APPR_PARAMCR INTO
			:pSource->aiIndexID,
			:pSource->aiApprID,
			:pSource->aiPercent;
		CheckSqlError("Fetch CR_BILL_TYPE_ACCT_APPR_PARAMCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_BILL_TYPE_ACCT_APPR_PARAMCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_BILL_TYPE_ACCT_APPR_PARAM_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iIndexID=	pSource->aiIndexID[iCurPos];
		p->iApprID=	pSource->aiApprID[iCurPos];
		p->iPercent=	pSource->aiPercent[iCurPos];


	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_BILL_TYPE_ACCT_APPR_PARAM的链表释放函数**/
void DestroyCrBillTypeAcctApprParam(struct CrBillTypeAcctApprParamStruct *ptHead)
{
	struct CrBillTypeAcctApprParamStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrBillTypeAcctApprParam(struct CrBillTypeAcctApprParamStruct **pptHead)
{
	int iCnt=0;
	static struct CrBillTypeAcctApprParamStruct *pTemp,*ptHead=NULL;
	struct CrBillTypeAcctApprParamStruct Temp;
	struct CrBillTypeAcctApprParamStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrBillTypeAcctApprParam(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrBillTypeAcctApprParamStructIn));
	sprintf(TempIn.sTableName,"CR_BILL_TYPE_ACCT_APPR_PARAM");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrBillTypeAcctApprParamToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrBillTypeAcctApprParamStruct*)
			malloc(sizeof(struct CrBillTypeAcctApprParamStruct)))==NULL){

			DestroyCrBillTypeAcctApprParam(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrBillTypeAcctApprParamStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_BILL_TYPE_ACCT_APPR_PARAM记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_BILL_TYPE_ACCT_APPR_PARAM完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从CR_SERVICE_TYPE_ACCT_APPR中用结构缓冲方式取数据*/
int EGetCrServiceTypeAcctApprToStruct(struct CrServiceTypeAcctApprStruct *p,
	struct CrServiceTypeAcctApprStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				SERVICE_APPR_ID,\n\
				nvl(ACCT_ITEM_TYPE_ID,0),\n\
				nvl(BILLING_TYPE_ID,' '),\n\
				METHOD\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_SERVICE_TYPE_ACCT_APPRSCR FROM :statement;
		CheckSqlError(" PREPARE CR_SERVICE_TYPE_ACCT_APPRSCR CR_SERVICE_TYPE_ACCT_APPRCR");

		EXEC SQL DECLARE CR_SERVICE_TYPE_ACCT_APPRCR CURSOR FOR CR_SERVICE_TYPE_ACCT_APPRSCR;
		CheckSqlError("Declare CR_SERVICE_TYPE_ACCT_APPRCR");

		EXEC SQL OPEN CR_SERVICE_TYPE_ACCT_APPRCR;
		CheckSqlError("Open CR_SERVICE_TYPE_ACCT_APPRCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_SERVICE_TYPE_ACCT_APPRCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_SERVICE_TYPE_ACCT_APPRCR INTO
			:pSource->aiServiceApprID,
			:pSource->aiAcctItemTypeID,
			:pSource->asBillingTypeID,
			:pSource->asMethod;
		CheckSqlError("Fetch CR_SERVICE_TYPE_ACCT_APPRCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_SERVICE_TYPE_ACCT_APPRCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_SERVICE_TYPE_ACCT_APPR_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iServiceApprID=		pSource->aiServiceApprID[iCurPos];
		p->iAcctItemTypeID=		pSource->aiAcctItemTypeID[iCurPos];

		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);
		strcpy(p->sMethod,		pSource->asMethod[iCurPos]);

		AllTrim(p->sBillingTypeID);
		AllTrim(p->sMethod);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_SERVICE_TYPE_ACCT_APPR的链表释放函数**/
void DestroyCrServiceTypeAcctAppr(struct CrServiceTypeAcctApprStruct *ptHead)
{
	struct CrServiceTypeAcctApprStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrServiceTypeAcctAppr(struct CrServiceTypeAcctApprStruct **pptHead)
{
	int iCnt=0;
	static struct CrServiceTypeAcctApprStruct *pTemp,*ptHead=NULL;
	struct CrServiceTypeAcctApprStruct Temp;
	struct CrServiceTypeAcctApprStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrServiceTypeAcctAppr(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrServiceTypeAcctApprStructIn));
	sprintf(TempIn.sTableName,"CR_SERVICE_TYPE_ACCT_APPR");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrServiceTypeAcctApprToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrServiceTypeAcctApprStruct*)
			malloc(sizeof(struct CrServiceTypeAcctApprStruct)))==NULL){

			DestroyCrServiceTypeAcctAppr(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrServiceTypeAcctApprStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_SERVICE_TYPE_ACCT_APPR记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_SERVICE_TYPE_ACCT_APPR完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从CR_SERV_TYPE_ACCT_APPR_PARAM中用结构缓冲方式取数据*/
int EGetCrServTypeAcctApprParamToStruct(struct CrServTypeAcctApprParamStruct *p,
	struct CrServTypeAcctApprParamStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(SERVICE_APPR_ID,0),\n\
				nvl(APPR_ID,0),\n\
				nvl(SERVICE_TYPE,' '),\n\
				nvl(VALUE,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_SERV_TYPE_ACCT_APPR_PARAMSCR FROM :statement;
		CheckSqlError(" PREPARE CR_SERV_TYPE_ACCT_APPR_PARAMSCR CR_SERV_TYPE_ACCT_APPR_PARAMCR");

		EXEC SQL DECLARE CR_SERV_TYPE_ACCT_APPR_PARAMCR CURSOR FOR CR_SERV_TYPE_ACCT_APPR_PARAMSCR;
		CheckSqlError("Declare CR_SERV_TYPE_ACCT_APPR_PARAMCR");

		EXEC SQL OPEN CR_SERV_TYPE_ACCT_APPR_PARAMCR;
		CheckSqlError("Open CR_SERV_TYPE_ACCT_APPR_PARAMCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_SERV_TYPE_ACCT_APPR_PARAMCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_SERV_TYPE_ACCT_APPR_PARAMCR INTO
			:pSource->aiServiceApprID,
			:pSource->aiApprID,
			:pSource->asServiceType,
			:pSource->aiValue;
		CheckSqlError("Fetch CR_SERV_TYPE_ACCT_APPR_PARAMCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_SERV_TYPE_ACCT_APPR_PARAMCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_SERV_TYPE_ACCT_APPR_PARAM_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iServiceApprID=	pSource->aiServiceApprID[iCurPos];
		p->iApprID=		pSource->aiApprID[iCurPos];

		strcpy(p->sServiceType,	pSource->asServiceType[iCurPos]);

		p->iValue=		pSource->aiValue[iCurPos];

		AllTrim(p->sServiceType);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_SERV_TYPE_ACCT_APPR_PARAM的链表释放函数**/
void DestroyCrServTypeAcctApprParam(struct CrServTypeAcctApprParamStruct *ptHead)
{
	struct CrServTypeAcctApprParamStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrServTypeAcctApprParam(struct CrServTypeAcctApprParamStruct **pptHead)
{
	int iCnt=0;
	static struct CrServTypeAcctApprParamStruct *pTemp,*ptHead=NULL;
	struct CrServTypeAcctApprParamStruct Temp;
	struct CrServTypeAcctApprParamStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrServTypeAcctApprParam(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrServTypeAcctApprParamStructIn));
	sprintf(TempIn.sTableName,"CR_SERV_TYPE_ACCT_APPR_PARAM");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrServTypeAcctApprParamToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrServTypeAcctApprParamStruct*)
			malloc(sizeof(struct CrServTypeAcctApprParamStruct)))==NULL){

			DestroyCrServTypeAcctApprParam(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrServTypeAcctApprParamStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_SERV_TYPE_ACCT_APPR_PARAM记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_SERV_TYPE_ACCT_APPR_PARAM完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从CR_SERVICE_INDEX中用结构缓冲方式取数据*/
int EGetCrServiceIndexToStruct(struct CrServiceIndexStruct *p,
	struct CrServiceIndexStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				INDEX_ID,\n\
				NAME,\n\
				nvl(LEAVE_FLAG,' '),\n\
				nvl(LAY,0),\n\
				nvl(PARENT_ID,0),\n\
				nvl(SERVICE_TYPE,' '),\n\
				nvl(TYPE,' '),\n\
				nvl(UNIT,' '),\n\
				nvl(CATG,' ')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_SERVICE_INDEXSCR FROM :statement;
		CheckSqlError(" PREPARE CR_SERVICE_INDEXSCR CR_SERVICE_INDEXCR");

		EXEC SQL DECLARE CR_SERVICE_INDEXCR CURSOR FOR CR_SERVICE_INDEXSCR;
		CheckSqlError("Declare CR_SERVICE_INDEXCR");

		EXEC SQL OPEN CR_SERVICE_INDEXCR;
		CheckSqlError("Open CR_SERVICE_INDEXCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_SERVICE_INDEXCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_SERVICE_INDEXCR INTO
			:pSource->aiIndexID,
			:pSource->asName,
			:pSource->asLeaveFlag,
			:pSource->aiLay,
			:pSource->aiParentID,
			:pSource->asServiceType,
			:pSource->asType,
			:pSource->asUnit,
			:pSource->asCatg;
		CheckSqlError("Fetch CR_SERVICE_INDEXCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_SERVICE_INDEXCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_SERVICE_INDEX_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		p->iIndexID=		pSource->aiIndexID[iCurPos];

		strcpy(p->sName,	pSource->asName[iCurPos]);
		strcpy(p->sLeaveFlag,	pSource->asLeaveFlag[iCurPos]);

		p->iLay=		pSource->aiLay[iCurPos];
		p->iParentID=		pSource->aiParentID[iCurPos];

		strcpy(p->sServiceType,	pSource->asServiceType[iCurPos]);
		strcpy(p->sType,	pSource->asType[iCurPos]);
		strcpy(p->sUnit,	pSource->asUnit[iCurPos]);
		strcpy(p->sCatg,	pSource->asCatg[iCurPos]);

		AllTrim(p->sName);
		AllTrim(p->sLeaveFlag);
		AllTrim(p->sServiceType);
		AllTrim(p->sType);
		AllTrim(p->sUnit);
		AllTrim(p->sCatg);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_SERVICE_INDEX的链表释放函数**/
void DestroyCrServiceIndex(struct CrServiceIndexStruct *ptHead)
{
	struct CrServiceIndexStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrServiceIndex(struct CrServiceIndexStruct **pptHead)
{
	int iCnt=0;
	static struct CrServiceIndexStruct *pTemp,*ptHead=NULL;
	struct CrServiceIndexStruct Temp;
	struct CrServiceIndexStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrServiceIndex(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrServiceIndexStructIn));
	sprintf(TempIn.sTableName,"CR_SERVICE_INDEX");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrServiceIndexToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrServiceIndexStruct*)
			malloc(sizeof(struct CrServiceIndexStruct)))==NULL){

			DestroyCrServiceIndex(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrServiceIndexStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_SERVICE_INDEX记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_SERVICE_INDEX完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从CR_PACKAGE_TARIFF_ID中用结构缓冲方式取数据*/
int EGetCrPackageTariffIDToStruct(struct CrPackageTariffIDStruct *p,
	struct CrPackageTariffIDStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(BILLING_TYPE_ID,' '),\n\
				SERVICE_TYPE,\n\
				TARIFF_ID\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_PACKAGE_TARIFF_IDSCR FROM :statement;
		CheckSqlError(" PREPARE CR_PACKAGE_TARIFF_IDSCR CR_PACKAGE_TARIFF_IDCR");

		EXEC SQL DECLARE CR_PACKAGE_TARIFF_IDCR CURSOR FOR CR_PACKAGE_TARIFF_IDSCR;
		CheckSqlError("Declare CR_PACKAGE_TARIFF_IDCR");

		EXEC SQL OPEN CR_PACKAGE_TARIFF_IDCR;
		CheckSqlError("Open CR_PACKAGE_TARIFF_IDCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_PACKAGE_TARIFF_IDCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_PACKAGE_TARIFF_IDCR INTO
			:pSource->asBillingTypeID,
			:pSource->asServiceType,
			:pSource->aiTariffID;
		CheckSqlError("Fetch CR_PACKAGE_TARIFF_IDCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_PACKAGE_TARIFF_IDCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_PACKAGE_TARIFF_ID_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);
		strcpy(p->sServiceType,		pSource->asServiceType[iCurPos]);

		p->iTariffID=			pSource->aiTariffID[iCurPos];

		AllTrim(p->sBillingTypeID);
		AllTrim(p->sServiceType);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_PACKAGE_TARIFF_ID的链表释放函数**/
void DestroyCrPackageTariffID(struct CrPackageTariffIDStruct *ptHead)
{
	struct CrPackageTariffIDStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrPackageTariffID(struct CrPackageTariffIDStruct **pptHead)
{
	int iCnt=0;
	static struct CrPackageTariffIDStruct *pTemp,*ptHead=NULL;
	struct CrPackageTariffIDStruct Temp;
	struct CrPackageTariffIDStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrPackageTariffID(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrPackageTariffIDStructIn));
	sprintf(TempIn.sTableName,"V_CR_PACKAGE_TARIFF_ID");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrPackageTariffIDToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrPackageTariffIDStruct*)
			malloc(sizeof(struct CrPackageTariffIDStruct)))==NULL){

			DestroyCrPackageTariffID(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrPackageTariffIDStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表V_CR_PACKAGE_TARIFF_ID记录数%d",iCnt);
	}

	WriteProcMsg("加载表V_CR_PACKAGE_TARIFF_ID完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从CR_INDEX_Y_GRADE中用结构缓冲方式取数据*/
int EGetCrIndexYGradeToStruct(struct CrIndexYGradeStruct *p,
	struct CrIndexYGradeStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(BILLING_TYPE_ID,' '),\n\
				nvl(SERVICE_TYPE,' '),\n\
				nvl(INDEX_ID,0),\n\
				nvl(INDEX_UNIT,' '),\n\
				nvl(Y_GRADE_ID,' '),\n\
				nvl(USR_PCT,0),\n\
				nvl(INC_PCT,0),\n\
				nvl(AVG_VOLUME,0),\n\
				nvl(CATG,' ')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_INDEX_Y_GRADESCR FROM :statement;
		CheckSqlError(" PREPARE CR_INDEX_Y_GRADESCR CR_INDEX_Y_GRADECR");

		EXEC SQL DECLARE CR_INDEX_Y_GRADECR CURSOR FOR CR_INDEX_Y_GRADESCR;
		CheckSqlError("Declare CR_INDEX_Y_GRADECR");

		EXEC SQL OPEN CR_INDEX_Y_GRADECR;
		CheckSqlError("Open CR_INDEX_Y_GRADECR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_INDEX_Y_GRADECR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_INDEX_Y_GRADECR INTO
			:pSource->asBillingTypeID,
			:pSource->asServiceType,
			:pSource->aiIndexID,
			:pSource->asIndexUnit,
			:pSource->asYGradeID,
			:pSource->adUsrPct,
			:pSource->adIncPct,
			:pSource->adAvgVolume,
			:pSource->asCatg;
		CheckSqlError("Fetch CR_INDEX_Y_GRADECR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_INDEX_Y_GRADECR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_INDEX_Y_GRADE_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);
		strcpy(p->sServiceType,		pSource->asServiceType[iCurPos]);

		p->iIndexID=			pSource->aiIndexID[iCurPos];

		strcpy(p->sIndexUnit,		pSource->asIndexUnit[iCurPos]);
		strcpy(p->sYGradeID,		pSource->asYGradeID[iCurPos]);

		p->dUsrPct=			pSource->adUsrPct[iCurPos];
		p->dIncPct=			pSource->adIncPct[iCurPos];
		p->dAvgVolume=			pSource->adAvgVolume[iCurPos];

		strcpy(p->sCatg,		pSource->asCatg[iCurPos]);

		AllTrim(p->sBillingTypeID);
		AllTrim(p->sServiceType);
		AllTrim(p->sIndexUnit);
		AllTrim(p->sYGradeID);
		AllTrim(p->sCatg);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_INDEX_Y_GRADE的链表释放函数**/
void DestroyCrIndexYGrade(struct CrIndexYGradeStruct *ptHead)
{
	struct CrIndexYGradeStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrIndexYGrade(struct CrIndexYGradeStruct **pptHead)
{
	int iCnt=0;
	static struct CrIndexYGradeStruct *pTemp,*ptHead=NULL;
	struct CrIndexYGradeStruct Temp;
	struct CrIndexYGradeStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrIndexYGrade(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrIndexYGradeStructIn));
	sprintf(TempIn.sTableName,"CR_INDEX_Y_GRADE");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrIndexYGradeToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrIndexYGradeStruct*)
			malloc(sizeof(struct CrIndexYGradeStruct)))==NULL){

			DestroyCrIndexYGrade(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrIndexYGradeStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_INDEX_Y_GRADE记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_INDEX_Y_GRADE完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从CR_INDEX_X_GRADE中用结构缓冲方式取数据*/
int EGetCrIndexXGradeToStruct(struct CrIndexXGradeStruct *p,
	struct CrIndexXGradeStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(BILLING_TYPE_ID,' '),\n\
				nvl(SERVICE_TYPE,' '),\n\
				nvl(INDEX_ID,0),\n\
				nvl(INDEX_UNIT,' '),\n\
				nvl(X_GRADE_ID,' '),\n\
				nvl(USR_PCT,0),\n\
				nvl(INC_PCT,0),\n\
				nvl(AVG_VOLUME,0),\n\
				nvl(CATG,' ')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_INDEX_X_GRADESCR FROM :statement;
		CheckSqlError(" PREPARE CR_INDEX_X_GRADESCR CR_INDEX_X_GRADECR");

		EXEC SQL DECLARE CR_INDEX_X_GRADECR CURSOR FOR CR_INDEX_X_GRADESCR;
		CheckSqlError("Declare CR_INDEX_X_GRADECR");

		EXEC SQL OPEN CR_INDEX_X_GRADECR;
		CheckSqlError("Open CR_INDEX_X_GRADECR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_INDEX_X_GRADECR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_INDEX_X_GRADECR INTO
			:pSource->asBillingTypeID,
			:pSource->asServiceType,
			:pSource->aiIndexID,
			:pSource->asIndexUnit,
			:pSource->asXGradeID,
			:pSource->adUsrPct,
			:pSource->adIncPct,
			:pSource->adAvgVolume,
			:pSource->asCatg;
		CheckSqlError("Fetch CR_INDEX_X_GRADECR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_INDEX_X_GRADECR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_INDEX_X_GRADE_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);
		strcpy(p->sServiceType,		pSource->asServiceType[iCurPos]);

		p->iIndexID=			pSource->aiIndexID[iCurPos];

		strcpy(p->sIndexUnit,		pSource->asIndexUnit[iCurPos]);
		strcpy(p->sXGradeID,		pSource->asXGradeID[iCurPos]);

		p->dUsrPct=			pSource->adUsrPct[iCurPos];
		p->dIncPct=			pSource->adIncPct[iCurPos];
		p->dAvgVolume=			pSource->adAvgVolume[iCurPos];

		strcpy(p->sCatg,		pSource->asCatg[iCurPos]);

		AllTrim(p->sBillingTypeID);
		AllTrim(p->sServiceType);
		AllTrim(p->sIndexUnit);
		AllTrim(p->sXGradeID);
		AllTrim(p->sCatg);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_INDEX_X_GRADE的链表释放函数**/
void DestroyCrIndexXGrade(struct CrIndexXGradeStruct *ptHead)
{
	struct CrIndexXGradeStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrIndexXGrade(struct CrIndexXGradeStruct **pptHead)
{
	int iCnt=0;
	static struct CrIndexXGradeStruct *pTemp,*ptHead=NULL;
	struct CrIndexXGradeStruct Temp;
	struct CrIndexXGradeStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrIndexXGrade(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrIndexXGradeStructIn));
	sprintf(TempIn.sTableName,"CR_INDEX_X_GRADE");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrIndexXGradeToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrIndexXGradeStruct*)
			malloc(sizeof(struct CrIndexXGradeStruct)))==NULL){

			DestroyCrIndexXGrade(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrIndexXGradeStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_INDEX_X_GRADE记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_INDEX_X_GRADE完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从CR_BILLING_TYPE_CORRELATION中用结构缓冲方式取数据*/
int EGetCrBillingTypeCorrelationToStruct(struct CrBillingTypeCorrelationStruct *p,
	struct CrBillingTypeCorrelationStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(TASK_ID,' '),\n\
				nvl(BILLING_TYPE_ID,' '),\n\
				nvl(CORRELATION_TYPE_ID,' '),\n\
				nvl(CATG,' '),\n\
				nvl(AREA_CODE,' '),\n\
				nvl(CORRELATION_TYPE,' '),\n\
				nvl(CORRELATION_COEFFICENT,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_BILLING_TYPE_CORRELATIONSCR FROM :statement;
		CheckSqlError(" PREPARE CR_BILLING_TYPE_CORRELATIONSCR CR_BILLING_TYPE_CORRELATIONCR");

		EXEC SQL DECLARE CR_BILLING_TYPE_CORRELATIONCR CURSOR FOR CR_BILLING_TYPE_CORRELATIONSCR;
		CheckSqlError("Declare CR_BILLING_TYPE_CORRELATIONCR");

		EXEC SQL OPEN CR_BILLING_TYPE_CORRELATIONCR;
		CheckSqlError("Open CR_BILLING_TYPE_CORRELATIONCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_BILLING_TYPE_CORRELATIONCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_BILLING_TYPE_CORRELATIONCR INTO
			:pSource->asTaskID,
			:pSource->asBillingTypeID,
			:pSource->asCorrelationTypeID,
			:pSource->asCatg,
			:pSource->asAreaCode,
			:pSource->asCorrelationType,
			:pSource->adCorrelationCoefficent;
		CheckSqlError("Fetch CR_BILLING_TYPE_CORRELATIONCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_BILLING_TYPE_CORRELATIONCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_BILLING_TYPE_CORRELATION_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sTaskID,		pSource->asTaskID[iCurPos]);
		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);
		strcpy(p->sCorrelationTypeID,	pSource->asCorrelationTypeID[iCurPos]);
		strcpy(p->sCatg,		pSource->asCatg[iCurPos]);
		strcpy(p->sAreaCode,		pSource->asAreaCode[iCurPos]);
		strcpy(p->sCorrelationType,	pSource->asCorrelationType[iCurPos]);

		p->dCorrelationCoefficent=	pSource->adCorrelationCoefficent[iCurPos];

		AllTrim(p->sTaskID);
		AllTrim(p->sBillingTypeID);
		AllTrim(p->sCorrelationTypeID);
		AllTrim(p->sCatg);
		AllTrim(p->sAreaCode);
		AllTrim(p->sCorrelationType);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}

/**对表CR_BILLING_TYPE_CORRELATION的链表释放函数**/
void DestroyCrBillingTypeCorrelation(struct CrBillingTypeCorrelationStruct *ptHead)
{
	struct CrBillingTypeCorrelationStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}

int InitCrBillingTypeCorrelation(struct CrBillingTypeCorrelationStruct **pptHead)
{
	int iCnt=0;
	static struct CrBillingTypeCorrelationStruct *pTemp,*ptHead=NULL;
	struct CrBillingTypeCorrelationStruct Temp;
	struct CrBillingTypeCorrelationStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrBillingTypeCorrelation(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrBillingTypeCorrelationStructIn));
	sprintf(TempIn.sTableName,"CR_BILLING_TYPE_CORRELATION");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrBillingTypeCorrelationToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrBillingTypeCorrelationStruct*)
			malloc(sizeof(struct CrBillingTypeCorrelationStruct)))==NULL){

			DestroyCrBillingTypeCorrelation(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrBillingTypeCorrelationStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_BILLING_TYPE_CORRELATION记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_BILLING_TYPE_CORRELATION完毕总记录数%d",iCnt);

	return iCnt;
}


/*批量数据动态从BILLING_TYPE中用结构缓冲方式取数据*/
int EGetBillingTypeToStruct(struct BillingTypeStruct *p,
	struct BillingTypeStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				BILLING_TYPE_ID,\n\
				nvl(TEMPLATE_ID,' '),\n\
				REMARK,\n\
				nvl(CATG,' '),\n\
				nvl(SERV_TYPE_ID,' '),\n\
				nvl(IMPL_PATTERN,' '),\n\
				nvl(AFFECT_SERVICE,' '),\n\
				nvl(METHOD,' ')\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE BILLING_TYPESCR FROM :statement;
		CheckSqlError(" PREPARE BILLING_TYPESCR BILLING_TYPECR");

		EXEC SQL DECLARE BILLING_TYPECR CURSOR FOR BILLING_TYPESCR;
		CheckSqlError("Declare BILLING_TYPECR");

		EXEC SQL OPEN BILLING_TYPECR;
		CheckSqlError("Open BILLING_TYPECR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE BILLING_TYPECR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH BILLING_TYPECR INTO
			:pSource->asBillingTypeID,
			:pSource->asTemplateID,
			:pSource->asRemark,
			:pSource->asCatg,
			:pSource->asServTypeID,
			:pSource->asImplPattern,
			:pSource->asAffectService,
			:pSource->asMethod;
		CheckSqlError("Fetch BILLING_TYPECR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE BILLING_TYPECR;

			return FALSE;
		}

		if(pSource->iRecCnt!=BILLING_TYPE_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);
		strcpy(p->sTemplateID,		pSource->asTemplateID[iCurPos]);
		strcpy(p->sRemark,		pSource->asRemark[iCurPos]);
		strcpy(p->sCatg,		pSource->asCatg[iCurPos]);
		strcpy(p->sServTypeID,		pSource->asServTypeID[iCurPos]);
		strcpy(p->sImplPattern,		pSource->asImplPattern[iCurPos]);
		strcpy(p->sAffectService,	pSource->asAffectService[iCurPos]);
		strcpy(p->sMethod,		pSource->asMethod[iCurPos]);

		AllTrim(p->sBillingTypeID);
		AllTrim(p->sTemplateID);
		AllTrim(p->sRemark);
		AllTrim(p->sCatg);
		AllTrim(p->sServTypeID);
		AllTrim(p->sImplPattern);
		AllTrim(p->sAffectService);
		AllTrim(p->sMethod);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表BILLING_TYPE的链表释放函数**/
void DestroyBillingType(struct BillingTypeStruct *ptHead)
{
	struct BillingTypeStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitBillingType(struct BillingTypeStruct **pptHead)
{
	int iCnt=0;
	static struct BillingTypeStruct *pTemp,*ptHead=NULL;
	struct BillingTypeStruct Temp;
	struct BillingTypeStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyBillingType(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct BillingTypeStructIn));
	sprintf(TempIn.sTableName,"BILLING_TYPE");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetBillingTypeToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct BillingTypeStruct*)
			malloc(sizeof(struct BillingTypeStruct)))==NULL){

			DestroyBillingType(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct BillingTypeStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表BILLING_TYPE记录数%d",iCnt);
	}

	WriteProcMsg("加载表BILLING_TYPE完毕总记录数%d",iCnt);

	return iCnt;
}

/*批量数据动态从CR_ACCT_ITEM_STAT中用结构缓冲方式取数据*/
int EGetCrAcctItemStatToStruct(struct CrAcctItemStatStruct *p,
	struct CrAcctItemStatStructIn *pSource)
{

	int  iCurPos=pSource->iCurPos;
	char *sTableName=pSource->sTableName;
	char *sCondition=pSource->sCondition;

	if(pSource->iFirstFlag){

/* CURSOR DEFINE */
		char statement[8192];

		sprintf(statement,"\n\
			SELECT \n\
				nvl(ACC_NBR,' '),\n\
				nvl(AREA_CODE,' '),\n\
				nvl(SUBSCRIPTION_ID,0),\n\
				nvl(ACCOUNT_ID,0),\n\
				nvl(SERVICE_TYPE,0),\n\
				nvl(BILLING_TYPE_ID,' '),\n\
				nvl(DESCRIPTION_ID,0),\n\
				nvl(SUBJECT_ID,0),\n\
				nvl(BILL_FEE,0),\n\
				nvl(DISCT_FEE,0)\n\
			FROM %s %s",sTableName,sCondition);

		EXEC SQL PREPARE CR_ACCT_ITEM_STATSCR FROM :statement;
		CheckSqlError(" PREPARE CR_ACCT_ITEM_STATSCR CR_ACCT_ITEM_STATCR");

		EXEC SQL DECLARE CR_ACCT_ITEM_STATCR CURSOR FOR CR_ACCT_ITEM_STATSCR;
		CheckSqlError("Declare CR_ACCT_ITEM_STATCR");

		EXEC SQL OPEN CR_ACCT_ITEM_STATCR;
		CheckSqlError("Open CR_ACCT_ITEM_STATCR;");


		pSource->iFirstFlag = pSource->iEndFlag = FALSE;
		pSource->iFetchRecNum = pSource->iCurPos = 0;
		pSource->iBufEmpty = TRUE;
	}

	if(pSource->iEndFlag==TRUE&&iCurPos==pSource->iRecCnt){

		pSource->iBufEmpty=TRUE;
		pSource->iCurPos=0;
		pSource->iFetchRecNum=0;
		pSource->iEndFlag=FALSE;
		pSource->iFirstFlag=TRUE;

		EXEC SQL CLOSE CR_ACCT_ITEM_STATCR;

		return FALSE;
	}

	if(pSource->iBufEmpty||!pSource->iFetchRecNum){

/* FETCH */
		EXEC SQL FETCH CR_ACCT_ITEM_STATCR INTO
			:pSource->asAccNbr,
			:pSource->asAreaCode,
			:pSource->aiSubscriptionID,
			:pSource->aiAccountID,
			:pSource->aiServiceType,
			:pSource->asBillingTypeID,
			:pSource->aiDescriptionID,
			:pSource->aiSubjectID,
			:pSource->aiBillFee,
			:pSource->aiDisctFee;
		CheckSqlError("Fetch CR_ACCT_ITEM_STATCR");

		pSource->iRecCnt=FetchColNum-pSource->iFetchRecNum;

		if(!pSource->iRecCnt){

			pSource->iBufEmpty=TRUE;
			pSource->iCurPos=0;
			pSource->iFetchRecNum=0;
			pSource->iEndFlag=FALSE;
			pSource->iFirstFlag=TRUE;

			EXEC SQL CLOSE CR_ACCT_ITEM_STATCR;

			return FALSE;
		}

		if(pSource->iRecCnt!=CR_ACCT_ITEM_STAT_BUFLEN_IN)
			pSource->iEndFlag = TRUE;

		pSource->iFetchRecNum=FetchColNum;
		pSource->iCurPos=0;
		iCurPos=0;
		pSource->iBufEmpty=FALSE;
	}

/* 从缓冲区取数据*/
		strcpy(p->sAccNbr,		pSource->asAccNbr[iCurPos]);
		strcpy(p->sAreaCode,		pSource->asAreaCode[iCurPos]);
		
		p->iSubscriptionID=		pSource->aiSubscriptionID[iCurPos];
		p->iAccountID=			pSource->aiAccountID[iCurPos];
		p->iServiceType=		pSource->aiServiceType[iCurPos];

		strcpy(p->sBillingTypeID,	pSource->asBillingTypeID[iCurPos]);
		
		p->iDescriptionID=		pSource->aiDescriptionID[iCurPos];
		p->iSubjectID=			pSource->aiSubjectID[iCurPos];
		p->iBillFee=			pSource->aiBillFee[iCurPos];
		p->iDisctFee=			pSource->aiDisctFee[iCurPos];

		AllTrim(p->sAccNbr);
		AllTrim(p->sAreaCode);
		AllTrim(p->sBillingTypeID);

	iCurPos++;

	if(iCurPos==pSource->iRecCnt)
		pSource->iBufEmpty=TRUE;
	pSource->iCurPos=iCurPos;
	return TRUE;
}
/**对表CR_ACCT_ITEM_STAT的链表释放函数**/
void DestroyCrAcctItemStat(struct CrAcctItemStatStruct *ptHead)
{
	struct CrAcctItemStatStruct *pTemp;
	while(ptHead!=NULL){
		pTemp=ptHead;
		ptHead=ptHead->pLoadNext;
		free(pTemp);
	}
}
int InitCrAcctItemStat(struct CrAcctItemStatStruct **pptHead)
{
	int iCnt=0;
	static struct CrAcctItemStatStruct *pTemp,*ptHead=NULL;
	struct CrAcctItemStatStruct Temp;
	struct CrAcctItemStatStructIn TempIn;

	*pptHead=NULL;
	/*释放内部链表**/
	DestroyCrAcctItemStat(ptHead);
	ptHead=NULL;

	/**初始化输入缓冲成员**/
	bzero((void*)&TempIn,sizeof(struct CrAcctItemStatStructIn));
	sprintf(TempIn.sTableName,"CR_ACCT_ITEM_STAT");
	sprintf(TempIn.sCondition," ");
	TempIn.iFirstFlag =TRUE;
	TempIn.iBufEmpty =TRUE;

	/*获取数据循环部分**/
	while(EGetCrAcctItemStatToStruct(&Temp,&TempIn)){

		Temp.pNext=NULL;
		Temp.pLoadNext=NULL;

		if((pTemp=(struct CrAcctItemStatStruct*)
			malloc(sizeof(struct CrAcctItemStatStruct)))==NULL){

			DestroyCrAcctItemStat(ptHead);
			ptHead=NULL;
			*pptHead=NULL;
			return -1;
		}

		memcpy((void*)pTemp,(void *)&Temp,sizeof(struct CrAcctItemStatStruct));

		pTemp->pLoadNext=ptHead;
		ptHead=pTemp;

		InsertList((LIST**)pptHead,(LIST*)pTemp);
		if((++iCnt%10000)==0)
			WriteProcMsg("加载表CR_ACCT_ITEM_STAT记录数%d",iCnt);
	}

	WriteProcMsg("加载表CR_ACCT_ITEM_STAT完毕总记录数%d",iCnt);

	return iCnt;
}


